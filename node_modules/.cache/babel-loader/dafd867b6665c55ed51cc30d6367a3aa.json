{"ast":null,"code":"/* interact.js 1.9.20 | https://raw.github.com/taye/interact.js/master/LICENSE */\n!function (t) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = t();else if (\"function\" == typeof define && define.amd) define([], t);else {\n    (\"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this).interact = t();\n  }\n}(function () {\n  var t = {};\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.default = void 0;\n\n  t.default = function (t) {\n    return !(!t || !t.Window) && t instanceof t.Window;\n  };\n\n  var e = {};\n  Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  }), e.init = r, e.getWindow = o, e.default = void 0;\n  var n = {\n    realWindow: void 0,\n    window: void 0,\n    getWindow: o,\n    init: r\n  };\n\n  function r(t) {\n    n.realWindow = t;\n    var e = t.document.createTextNode(\"\");\n    e.ownerDocument !== t.document && \"function\" == typeof t.wrap && t.wrap(e) === e && (t = t.wrap(t)), n.window = t;\n  }\n\n  function o(e) {\n    return (0, t.default)(e) ? e : (e.ownerDocument || e).defaultView || n.window;\n  }\n\n  \"undefined\" == typeof window ? (n.window = void 0, n.realWindow = void 0) : r(window), n.init = r;\n  var i = n;\n  e.default = i;\n  var a = {};\n\n  function s(t) {\n    return (s = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  Object.defineProperty(a, \"__esModule\", {\n    value: !0\n  }), a.default = void 0;\n\n  var l = function l(t) {\n    return !!t && \"object\" === s(t);\n  },\n      u = function u(t) {\n    return \"function\" == typeof t;\n  },\n      c = {\n    window: function window(n) {\n      return n === e.default.window || (0, t.default)(n);\n    },\n    docFrag: function docFrag(t) {\n      return l(t) && 11 === t.nodeType;\n    },\n    object: l,\n    func: u,\n    number: function number(t) {\n      return \"number\" == typeof t;\n    },\n    bool: function bool(t) {\n      return \"boolean\" == typeof t;\n    },\n    string: function string(t) {\n      return \"string\" == typeof t;\n    },\n    element: function element(t) {\n      if (!t || \"object\" !== s(t)) return !1;\n      var n = e.default.getWindow(t) || e.default.window;\n      return /object|function/.test(s(n.Element)) ? t instanceof n.Element : 1 === t.nodeType && \"string\" == typeof t.nodeName;\n    },\n    plainObject: function plainObject(t) {\n      return l(t) && !!t.constructor && /function Object\\b/.test(t.constructor.toString());\n    },\n    array: function array(t) {\n      return l(t) && void 0 !== t.length && u(t.splice);\n    }\n  };\n\n  a.default = c;\n  var f = {};\n\n  function d(t) {\n    var e = t.interaction;\n\n    if (\"drag\" === e.prepared.name) {\n      var n = e.prepared.axis;\n      \"x\" === n ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : \"y\" === n && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);\n    }\n  }\n\n  function p(t) {\n    var e = t.iEvent,\n        n = t.interaction;\n\n    if (\"drag\" === n.prepared.name) {\n      var r = n.prepared.axis;\n\n      if (\"x\" === r || \"y\" === r) {\n        var o = \"x\" === r ? \"y\" : \"x\";\n        e.page[o] = n.coords.start.page[o], e.client[o] = n.coords.start.client[o], e.delta[o] = 0;\n      }\n    }\n  }\n\n  Object.defineProperty(f, \"__esModule\", {\n    value: !0\n  }), f.default = void 0;\n  var v = {\n    id: \"actions/drag\",\n    install: function install(t) {\n      var e = t.actions,\n          n = t.Interactable,\n          r = t.defaults;\n      n.prototype.draggable = v.draggable, e.map.drag = v, e.methodDict.drag = \"draggable\", r.actions.drag = v.defaults;\n    },\n    listeners: {\n      \"interactions:before-action-move\": d,\n      \"interactions:action-resume\": d,\n      \"interactions:action-move\": p,\n      \"auto-start:check\": function autoStartCheck(t) {\n        var e = t.interaction,\n            n = t.interactable,\n            r = t.buttons,\n            o = n.options.drag;\n        if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (r & n.options.drag.mouseButtons))) return t.action = {\n          name: \"drag\",\n          axis: \"start\" === o.lockAxis ? o.startAxis : o.lockAxis\n        }, !1;\n      }\n    },\n    draggable: function draggable(t) {\n      return a.default.object(t) ? (this.options.drag.enabled = !1 !== t.enabled, this.setPerAction(\"drag\", t), this.setOnEvents(\"drag\", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : a.default.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;\n    },\n    beforeMove: d,\n    move: p,\n    defaults: {\n      startAxis: \"xy\",\n      lockAxis: \"xy\"\n    },\n    getCursor: function getCursor() {\n      return \"move\";\n    }\n  },\n      h = v;\n  f.default = h;\n  var g = {};\n  Object.defineProperty(g, \"__esModule\", {\n    value: !0\n  }), g.default = void 0;\n  var y = {\n    init: function init(t) {\n      var e = t;\n      y.document = e.document, y.DocumentFragment = e.DocumentFragment || m, y.SVGElement = e.SVGElement || m, y.SVGSVGElement = e.SVGSVGElement || m, y.SVGElementInstance = e.SVGElementInstance || m, y.Element = e.Element || m, y.HTMLElement = e.HTMLElement || y.Element, y.Event = e.Event, y.Touch = e.Touch || m, y.PointerEvent = e.PointerEvent || e.MSPointerEvent;\n    },\n    document: null,\n    DocumentFragment: null,\n    SVGElement: null,\n    SVGSVGElement: null,\n    SVGElementInstance: null,\n    Element: null,\n    HTMLElement: null,\n    Event: null,\n    Touch: null,\n    PointerEvent: null\n  };\n\n  function m() {}\n\n  var b = y;\n  g.default = b;\n  var x = {};\n  Object.defineProperty(x, \"__esModule\", {\n    value: !0\n  }), x.default = void 0;\n  var w = {\n    init: function init(t) {\n      var n = g.default.Element,\n          r = e.default.window.navigator;\n      w.supportsTouch = \"ontouchstart\" in t || a.default.func(t.DocumentTouch) && g.default.document instanceof t.DocumentTouch, w.supportsPointerEvent = !1 !== r.pointerEnabled && !!g.default.PointerEvent, w.isIOS = /iP(hone|od|ad)/.test(r.platform), w.isIOS7 = /iP(hone|od|ad)/.test(r.platform) && /OS 7[^\\d]/.test(r.appVersion), w.isIe9 = /MSIE 9/.test(r.userAgent), w.isOperaMobile = \"Opera\" === r.appName && w.supportsTouch && /Presto/.test(r.userAgent), w.prefixedMatchesSelector = \"matches\" in n.prototype ? \"matches\" : \"webkitMatchesSelector\" in n.prototype ? \"webkitMatchesSelector\" : \"mozMatchesSelector\" in n.prototype ? \"mozMatchesSelector\" : \"oMatchesSelector\" in n.prototype ? \"oMatchesSelector\" : \"msMatchesSelector\", w.pEventTypes = w.supportsPointerEvent ? g.default.PointerEvent === t.MSPointerEvent ? {\n        up: \"MSPointerUp\",\n        down: \"MSPointerDown\",\n        over: \"mouseover\",\n        out: \"mouseout\",\n        move: \"MSPointerMove\",\n        cancel: \"MSPointerCancel\"\n      } : {\n        up: \"pointerup\",\n        down: \"pointerdown\",\n        over: \"pointerover\",\n        out: \"pointerout\",\n        move: \"pointermove\",\n        cancel: \"pointercancel\"\n      } : null, w.wheelEvent = \"onmousewheel\" in g.default.document ? \"mousewheel\" : \"wheel\";\n    },\n    supportsTouch: null,\n    supportsPointerEvent: null,\n    isIOS7: null,\n    isIOS: null,\n    isIe9: null,\n    isOperaMobile: null,\n    prefixedMatchesSelector: null,\n    pEventTypes: null,\n    wheelEvent: null\n  };\n  var _ = w;\n  x.default = _;\n  var S = {};\n\n  function P(t) {\n    var e = t.parentNode;\n\n    if (a.default.docFrag(e)) {\n      for (; (e = e.host) && a.default.docFrag(e););\n\n      return e;\n    }\n\n    return e;\n  }\n\n  function O(t, n) {\n    return e.default.window !== e.default.realWindow && (n = n.replace(/\\/deep\\//g, \" \")), t[x.default.prefixedMatchesSelector](n);\n  }\n\n  Object.defineProperty(S, \"__esModule\", {\n    value: !0\n  }), S.nodeContains = function (t, e) {\n    for (; e;) {\n      if (e === t) return !0;\n      e = e.parentNode;\n    }\n\n    return !1;\n  }, S.closest = function (t, e) {\n    for (; a.default.element(t);) {\n      if (O(t, e)) return t;\n      t = P(t);\n    }\n\n    return null;\n  }, S.parentNode = P, S.matchesSelector = O, S.indexOfDeepestElement = function (t) {\n    for (var n, r = [], o = 0; o < t.length; o++) {\n      var i = t[o],\n          a = t[n];\n      if (i && o !== n) if (a) {\n        var s = E(i),\n            l = E(a);\n        if (s !== i.ownerDocument) if (l !== i.ownerDocument) {\n          if (s !== l) {\n            r = r.length ? r : T(a);\n            var u = void 0;\n\n            if (a instanceof g.default.HTMLElement && i instanceof g.default.SVGElement && !(i instanceof g.default.SVGSVGElement)) {\n              if (i === l) continue;\n              u = i.ownerSVGElement;\n            } else u = i;\n\n            for (var c = T(u, a.ownerDocument), f = 0; c[f] && c[f] === r[f];) f++;\n\n            for (var d = [c[f - 1], c[f], r[f]], p = d[0].lastChild; p;) {\n              if (p === d[1]) {\n                n = o, r = c;\n                break;\n              }\n\n              if (p === d[2]) break;\n              p = p.previousSibling;\n            }\n          } else v = i, h = a, y = void 0, m = void 0, y = parseInt((0, e.getWindow)(v).getComputedStyle(v).zIndex, 10) || 0, m = parseInt((0, e.getWindow)(h).getComputedStyle(h).zIndex, 10) || 0, y >= m && (n = o);\n        } else n = o;\n      } else n = o;\n    }\n\n    var v, h, y, m;\n    return n;\n  }, S.matchesUpTo = function (t, e, n) {\n    for (; a.default.element(t);) {\n      if (O(t, e)) return !0;\n      if ((t = P(t)) === n) return O(t, e);\n    }\n\n    return !1;\n  }, S.getActualElement = function (t) {\n    return t instanceof g.default.SVGElementInstance ? t.correspondingUseElement : t;\n  }, S.getScrollXY = M, S.getElementClientRect = j, S.getElementRect = function (t) {\n    var n = j(t);\n\n    if (!x.default.isIOS7 && n) {\n      var r = M(e.default.getWindow(t));\n      n.left += r.x, n.right += r.x, n.top += r.y, n.bottom += r.y;\n    }\n\n    return n;\n  }, S.getPath = function (t) {\n    var e = [];\n\n    for (; t;) e.push(t), t = P(t);\n\n    return e;\n  }, S.trySelector = function (t) {\n    if (!a.default.string(t)) return !1;\n    return g.default.document.querySelector(t), !0;\n  };\n\n  var E = function E(t) {\n    return t.parentNode || t.host;\n  };\n\n  function T(t, e) {\n    for (var n, r = [], o = t; (n = E(o)) && o !== e && n !== o.ownerDocument;) r.unshift(o), o = n;\n\n    return r;\n  }\n\n  function M(t) {\n    return {\n      x: (t = t || e.default.window).scrollX || t.document.documentElement.scrollLeft,\n      y: t.scrollY || t.document.documentElement.scrollTop\n    };\n  }\n\n  function j(t) {\n    var e = t instanceof g.default.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];\n    return e && {\n      left: e.left,\n      right: e.right,\n      top: e.top,\n      bottom: e.bottom,\n      width: e.width || e.right - e.left,\n      height: e.height || e.bottom - e.top\n    };\n  }\n\n  var k = {};\n  Object.defineProperty(k, \"__esModule\", {\n    value: !0\n  }), k.default = function (t, e) {\n    for (var n in e) t[n] = e[n];\n\n    return t;\n  };\n  var I = {};\n\n  function D(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  function A(t, e, n) {\n    return \"parent\" === t ? (0, S.parentNode)(n) : \"self\" === t ? e.getRect(n) : (0, S.closest)(n, t);\n  }\n\n  Object.defineProperty(I, \"__esModule\", {\n    value: !0\n  }), I.getStringOptionResult = A, I.resolveRectLike = function (t, e, n, r) {\n    var o = t;\n    a.default.string(o) ? o = A(o, e, n) : a.default.func(o) && (o = o.apply(void 0, function (t) {\n      if (Array.isArray(t)) return D(t);\n    }(i = r) || function (t) {\n      if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);\n    }(i) || function (t, e) {\n      if (t) {\n        if (\"string\" == typeof t) return D(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? D(t, e) : void 0;\n      }\n    }(i) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }()));\n    var i;\n    a.default.element(o) && (o = (0, S.getElementRect)(o));\n    return o;\n  }, I.rectToXY = function (t) {\n    return t && {\n      x: \"x\" in t ? t.x : t.left,\n      y: \"y\" in t ? t.y : t.top\n    };\n  }, I.xywhToTlbr = function (t) {\n    !t || \"left\" in t && \"top\" in t || ((t = (0, k.default)({}, t)).left = t.x || 0, t.top = t.y || 0, t.right = t.right || t.left + t.width, t.bottom = t.bottom || t.top + t.height);\n    return t;\n  }, I.tlbrToXywh = function (t) {\n    !t || \"x\" in t && \"y\" in t || ((t = (0, k.default)({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y);\n    return t;\n  }, I.addEdges = function (t, e, n) {\n    t.left && (e.left += n.x);\n    t.right && (e.right += n.x);\n    t.top && (e.top += n.y);\n    t.bottom && (e.bottom += n.y);\n    e.width = e.right - e.left, e.height = e.bottom - e.top;\n  };\n  var z = {};\n  Object.defineProperty(z, \"__esModule\", {\n    value: !0\n  }), z.default = function (t, e, n) {\n    var r = t.options[n],\n        o = r && r.origin || t.options.origin,\n        i = (0, I.resolveRectLike)(o, t, e, [t && e]);\n    return (0, I.rectToXY)(i) || {\n      x: 0,\n      y: 0\n    };\n  };\n  var C = {};\n\n  function R(t) {\n    return t.trim().split(/ +/);\n  }\n\n  Object.defineProperty(C, \"__esModule\", {\n    value: !0\n  }), C.default = function t(e, n, r) {\n    r = r || {}, a.default.string(e) && -1 !== e.search(\" \") && (e = R(e));\n    if (a.default.array(e)) return e.reduce(function (e, o) {\n      return (0, k.default)(e, t(o, n, r));\n    }, r);\n    a.default.object(e) && (n = e, e = \"\");\n    if (a.default.func(n)) r[e] = r[e] || [], r[e].push(n);else if (a.default.array(n)) for (var o = 0; o < n.length; o++) {\n      var i;\n      i = n[o], t(e, i, r);\n    } else if (a.default.object(n)) for (var s in n) {\n      var l = R(s).map(function (t) {\n        return \"\".concat(e).concat(t);\n      });\n      t(l, n[s], r);\n    }\n    return r;\n  };\n  var F = {};\n  Object.defineProperty(F, \"__esModule\", {\n    value: !0\n  }), F.default = void 0;\n\n  F.default = function (t, e) {\n    return Math.sqrt(t * t + e * e);\n  };\n\n  var X = {};\n\n  function Y(t, e) {\n    for (var n in e) {\n      var r = Y.prefixedPropREs,\n          o = !1;\n\n      for (var i in r) if (0 === n.indexOf(i) && r[i].test(n)) {\n        o = !0;\n        break;\n      }\n\n      o || \"function\" == typeof e[n] || (t[n] = e[n]);\n    }\n\n    return t;\n  }\n\n  Object.defineProperty(X, \"__esModule\", {\n    value: !0\n  }), X.default = void 0, Y.prefixedPropREs = {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/,\n    moz: /(Pressure)$/\n  };\n  var W = Y;\n  X.default = W;\n  var L = {};\n\n  function B(t) {\n    return t instanceof g.default.Event || t instanceof g.default.Touch;\n  }\n\n  function U(t, e, n) {\n    return t = t || \"page\", (n = n || {}).x = e[t + \"X\"], n.y = e[t + \"Y\"], n;\n  }\n\n  function V(t, e) {\n    return e = e || {\n      x: 0,\n      y: 0\n    }, x.default.isOperaMobile && B(t) ? (U(\"screen\", t, e), e.x += window.scrollX, e.y += window.scrollY) : U(\"page\", t, e), e;\n  }\n\n  function q(t, e) {\n    return e = e || {}, x.default.isOperaMobile && B(t) ? U(\"screen\", t, e) : U(\"client\", t, e), e;\n  }\n\n  function N(t) {\n    var e = [];\n    return a.default.array(t) ? (e[0] = t[0], e[1] = t[1]) : \"touchend\" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;\n  }\n\n  function $(t) {\n    for (var e = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    }, n = 0; n < t.length; n++) {\n      var r = t[n];\n\n      for (var o in e) e[o] += r[o];\n    }\n\n    for (var i in e) e[i] /= t.length;\n\n    return e;\n  }\n\n  Object.defineProperty(L, \"__esModule\", {\n    value: !0\n  }), L.copyCoords = function (t, e) {\n    t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;\n  }, L.setCoordDeltas = function (t, e, n) {\n    t.page.x = n.page.x - e.page.x, t.page.y = n.page.y - e.page.y, t.client.x = n.client.x - e.client.x, t.client.y = n.client.y - e.client.y, t.timeStamp = n.timeStamp - e.timeStamp;\n  }, L.setCoordVelocity = function (t, e) {\n    var n = Math.max(e.timeStamp / 1e3, .001);\n    t.page.x = e.page.x / n, t.page.y = e.page.y / n, t.client.x = e.client.x / n, t.client.y = e.client.y / n, t.timeStamp = n;\n  }, L.setZeroCoords = function (t) {\n    t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;\n  }, L.isNativePointer = B, L.getXY = U, L.getPageXY = V, L.getClientXY = q, L.getPointerId = function (t) {\n    return a.default.number(t.pointerId) ? t.pointerId : t.identifier;\n  }, L.setCoords = function (t, e, n) {\n    var r = e.length > 1 ? $(e) : e[0],\n        o = {};\n    V(r, o), t.page.x = o.x, t.page.y = o.y, q(r, o), t.client.x = o.x, t.client.y = o.y, t.timeStamp = n;\n  }, L.getTouchPair = N, L.pointerAverage = $, L.touchBBox = function (t) {\n    if (!(t.length || t.touches && t.touches.length > 1)) return null;\n    var e = N(t),\n        n = Math.min(e[0].pageX, e[1].pageX),\n        r = Math.min(e[0].pageY, e[1].pageY),\n        o = Math.max(e[0].pageX, e[1].pageX),\n        i = Math.max(e[0].pageY, e[1].pageY);\n    return {\n      x: n,\n      y: r,\n      left: n,\n      top: r,\n      right: o,\n      bottom: i,\n      width: o - n,\n      height: i - r\n    };\n  }, L.touchDistance = function (t, e) {\n    var n = e + \"X\",\n        r = e + \"Y\",\n        o = N(t),\n        i = o[0][n] - o[1][n],\n        a = o[0][r] - o[1][r];\n    return (0, F.default)(i, a);\n  }, L.touchAngle = function (t, e) {\n    var n = e + \"X\",\n        r = e + \"Y\",\n        o = N(t),\n        i = o[1][n] - o[0][n],\n        a = o[1][r] - o[0][r];\n    return 180 * Math.atan2(a, i) / Math.PI;\n  }, L.getPointerType = function (t) {\n    return a.default.string(t.pointerType) ? t.pointerType : a.default.number(t.pointerType) ? [void 0, void 0, \"touch\", \"pen\", \"mouse\"][t.pointerType] : /touch/.test(t.type) || t instanceof g.default.Touch ? \"touch\" : \"mouse\";\n  }, L.getEventTargets = function (t) {\n    var e = a.default.func(t.composedPath) ? t.composedPath() : t.path;\n    return [S.getActualElement(e ? e[0] : t.target), S.getActualElement(t.currentTarget)];\n  }, L.newCoords = function () {\n    return {\n      page: {\n        x: 0,\n        y: 0\n      },\n      client: {\n        x: 0,\n        y: 0\n      },\n      timeStamp: 0\n    };\n  }, L.coordsToEvent = function (t) {\n    return {\n      coords: t,\n\n      get page() {\n        return this.coords.page;\n      },\n\n      get client() {\n        return this.coords.client;\n      },\n\n      get timeStamp() {\n        return this.coords.timeStamp;\n      },\n\n      get pageX() {\n        return this.coords.page.x;\n      },\n\n      get pageY() {\n        return this.coords.page.y;\n      },\n\n      get clientX() {\n        return this.coords.client.x;\n      },\n\n      get clientY() {\n        return this.coords.client.y;\n      },\n\n      get pointerId() {\n        return this.coords.pointerId;\n      },\n\n      get target() {\n        return this.coords.target;\n      },\n\n      get type() {\n        return this.coords.type;\n      },\n\n      get pointerType() {\n        return this.coords.pointerType;\n      },\n\n      get buttons() {\n        return this.coords.buttons;\n      },\n\n      preventDefault: function preventDefault() {}\n    };\n  }, Object.defineProperty(L, \"pointerExtend\", {\n    enumerable: !0,\n    get: function get() {\n      return X.default;\n    }\n  });\n  var G = {};\n\n  function H(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  Object.defineProperty(G, \"__esModule\", {\n    value: !0\n  }), G.default = G.BaseEvent = void 0;\n\n  var K = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.type = void 0, this.target = void 0, this.currentTarget = void 0, this.interactable = void 0, this._interaction = void 0, this.timeStamp = void 0, this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = e;\n    }\n\n    var e, n, r;\n    return e = t, (n = [{\n      key: \"preventDefault\",\n      value: function value() {}\n    }, {\n      key: \"stopPropagation\",\n      value: function value() {\n        this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function value() {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }]) && H(e.prototype, n), r && H(e, r), t;\n  }();\n\n  G.BaseEvent = K, Object.defineProperty(K.prototype, \"interaction\", {\n    get: function get() {\n      return this._interaction._proxy;\n    },\n    set: function set() {}\n  });\n  var Z = K;\n  G.default = Z;\n  var J = {};\n  Object.defineProperty(J, \"__esModule\", {\n    value: !0\n  }), J.find = J.findIndex = J.from = J.merge = J.remove = J.contains = void 0;\n\n  J.contains = function (t, e) {\n    return -1 !== t.indexOf(e);\n  };\n\n  J.remove = function (t, e) {\n    return t.splice(t.indexOf(e), 1);\n  };\n\n  var Q = function Q(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      t.push(r);\n    }\n\n    return t;\n  };\n\n  J.merge = Q;\n\n  J.from = function (t) {\n    return Q([], t);\n  };\n\n  var tt = function tt(t, e) {\n    for (var n = 0; n < t.length; n++) if (e(t[n], n, t)) return n;\n\n    return -1;\n  };\n\n  J.findIndex = tt;\n\n  J.find = function (t, e) {\n    return t[tt(t, e)];\n  };\n\n  var et = {};\n\n  function nt(t) {\n    return (nt = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  function rt(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function ot(t, e) {\n    return (ot = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function it(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var n,\n          r = st(t);\n\n      if (e) {\n        var o = st(this).constructor;\n        n = Reflect.construct(r, arguments, o);\n      } else n = r.apply(this, arguments);\n\n      return at(this, n);\n    };\n  }\n\n  function at(t, e) {\n    return !e || \"object\" !== nt(e) && \"function\" != typeof e ? function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }(t) : e;\n  }\n\n  function st(t) {\n    return (st = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n\n  Object.defineProperty(et, \"__esModule\", {\n    value: !0\n  }), et.DropEvent = void 0;\n\n  var lt = function (t) {\n    !function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && ot(t, e);\n    }(i, t);\n    var e,\n        n,\n        r,\n        o = it(i);\n\n    function i(t, e, n) {\n      var r;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, i), (r = o.call(this, e._interaction)).target = void 0, r.dropzone = void 0, r.dragEvent = void 0, r.relatedTarget = void 0, r.draggable = void 0, r.timeStamp = void 0, r.propagationStopped = !1, r.immediatePropagationStopped = !1;\n      var a = \"dragleave\" === n ? t.prev : t.cur,\n          s = a.element,\n          l = a.dropzone;\n      return r.type = n, r.target = s, r.currentTarget = s, r.dropzone = l, r.dragEvent = e, r.relatedTarget = e.target, r.draggable = e.interactable, r.timeStamp = e.timeStamp, r;\n    }\n\n    return e = i, (n = [{\n      key: \"reject\",\n      value: function value() {\n        var t = this,\n            e = this._interaction.dropState;\n        if (\"dropactivate\" === this.type || this.dropzone && e.cur.dropzone === this.dropzone && e.cur.element === this.target) if (e.prev.dropzone = this.dropzone, e.prev.element = this.target, e.rejected = !0, e.events.enter = null, this.stopImmediatePropagation(), \"dropactivate\" === this.type) {\n          var n = e.activeDrops,\n              r = J.findIndex(n, function (e) {\n            var n = e.dropzone,\n                r = e.element;\n            return n === t.dropzone && r === t.target;\n          });\n          e.activeDrops.splice(r, 1);\n          var o = new i(e, this.dragEvent, \"dropdeactivate\");\n          o.dropzone = this.dropzone, o.target = this.target, this.dropzone.fire(o);\n        } else this.dropzone.fire(new i(e, this.dragEvent, \"dragleave\"));\n      }\n    }, {\n      key: \"preventDefault\",\n      value: function value() {}\n    }, {\n      key: \"stopPropagation\",\n      value: function value() {\n        this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function value() {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }]) && rt(e.prototype, n), r && rt(e, r), i;\n  }(G.BaseEvent);\n\n  et.DropEvent = lt;\n  var ut = {};\n\n  function ct(t, e) {\n    for (var n = 0; n < t.slice().length; n++) {\n      var r = t.slice()[n],\n          o = r.dropzone,\n          i = r.element;\n      e.dropzone = o, e.target = i, o.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;\n    }\n  }\n\n  function ft(t, e) {\n    for (var n = function (t, e) {\n      for (var n = t.interactables, r = [], o = 0; o < n.list.length; o++) {\n        var i = n.list[o];\n\n        if (i.options.drop.enabled) {\n          var s = i.options.drop.accept;\n          if (!(a.default.element(s) && s !== e || a.default.string(s) && !S.matchesSelector(e, s) || a.default.func(s) && !s({\n            dropzone: i,\n            draggableElement: e\n          }))) for (var l = a.default.string(i.target) ? i._context.querySelectorAll(i.target) : a.default.array(i.target) ? i.target : [i.target], u = 0; u < l.length; u++) {\n            var c = l[u];\n            c !== e && r.push({\n              dropzone: i,\n              element: c\n            });\n          }\n        }\n      }\n\n      return r;\n    }(t, e), r = 0; r < n.length; r++) {\n      var o = n[r];\n      o.rect = o.dropzone.getRect(o.element);\n    }\n\n    return n;\n  }\n\n  function dt(t, e, n) {\n    for (var r = t.dropState, o = t.interactable, i = t.element, a = [], s = 0; s < r.activeDrops.length; s++) {\n      var l = r.activeDrops[s],\n          u = l.dropzone,\n          c = l.element,\n          f = l.rect;\n      a.push(u.dropCheck(e, n, o, i, c, f) ? c : null);\n    }\n\n    var d = S.indexOfDeepestElement(a);\n    return r.activeDrops[d] || null;\n  }\n\n  function pt(t, e, n) {\n    var r = t.dropState,\n        o = {\n      enter: null,\n      leave: null,\n      activate: null,\n      deactivate: null,\n      move: null,\n      drop: null\n    };\n    return \"dragstart\" === n.type && (o.activate = new et.DropEvent(r, n, \"dropactivate\"), o.activate.target = null, o.activate.dropzone = null), \"dragend\" === n.type && (o.deactivate = new et.DropEvent(r, n, \"dropdeactivate\"), o.deactivate.target = null, o.deactivate.dropzone = null), r.rejected || (r.cur.element !== r.prev.element && (r.prev.dropzone && (o.leave = new et.DropEvent(r, n, \"dragleave\"), n.dragLeave = o.leave.target = r.prev.element, n.prevDropzone = o.leave.dropzone = r.prev.dropzone), r.cur.dropzone && (o.enter = new et.DropEvent(r, n, \"dragenter\"), n.dragEnter = r.cur.element, n.dropzone = r.cur.dropzone)), \"dragend\" === n.type && r.cur.dropzone && (o.drop = new et.DropEvent(r, n, \"drop\"), n.dropzone = r.cur.dropzone, n.relatedTarget = r.cur.element), \"dragmove\" === n.type && r.cur.dropzone && (o.move = new et.DropEvent(r, n, \"dropmove\"), o.move.dragmove = n, n.dropzone = r.cur.dropzone)), o;\n  }\n\n  function vt(t, e) {\n    var n = t.dropState,\n        r = n.activeDrops,\n        o = n.cur,\n        i = n.prev;\n    e.leave && i.dropzone.fire(e.leave), e.move && o.dropzone.fire(e.move), e.enter && o.dropzone.fire(e.enter), e.drop && o.dropzone.fire(e.drop), e.deactivate && ct(r, e.deactivate), n.prev.dropzone = o.dropzone, n.prev.element = o.element;\n  }\n\n  function ht(t, e) {\n    var n = t.interaction,\n        r = t.iEvent,\n        o = t.event;\n\n    if (\"dragmove\" === r.type || \"dragend\" === r.type) {\n      var i = n.dropState;\n      e.dynamicDrop && (i.activeDrops = ft(e, n.element));\n      var a = r,\n          s = dt(n, a, o);\n      i.rejected = i.rejected && !!s && s.dropzone === i.cur.dropzone && s.element === i.cur.element, i.cur.dropzone = s && s.dropzone, i.cur.element = s && s.element, i.events = pt(n, 0, a);\n    }\n  }\n\n  Object.defineProperty(ut, \"__esModule\", {\n    value: !0\n  }), ut.default = void 0;\n  var gt = {\n    id: \"actions/drop\",\n    install: function install(t) {\n      var e = t.actions,\n          n = t.interactStatic,\n          r = t.Interactable,\n          o = t.defaults;\n      t.usePlugin(f.default), r.prototype.dropzone = function (t) {\n        return function (t, e) {\n          if (a.default.object(e)) {\n            if (t.options.drop.enabled = !1 !== e.enabled, e.listeners) {\n              var n = (0, C.default)(e.listeners),\n                  r = Object.keys(n).reduce(function (t, e) {\n                return t[/^(enter|leave)/.test(e) ? \"drag\".concat(e) : /^(activate|deactivate|move)/.test(e) ? \"drop\".concat(e) : e] = n[e], t;\n              }, {});\n              t.off(t.options.drop.listeners), t.on(r), t.options.drop.listeners = r;\n            }\n\n            return a.default.func(e.ondrop) && t.on(\"drop\", e.ondrop), a.default.func(e.ondropactivate) && t.on(\"dropactivate\", e.ondropactivate), a.default.func(e.ondropdeactivate) && t.on(\"dropdeactivate\", e.ondropdeactivate), a.default.func(e.ondragenter) && t.on(\"dragenter\", e.ondragenter), a.default.func(e.ondragleave) && t.on(\"dragleave\", e.ondragleave), a.default.func(e.ondropmove) && t.on(\"dropmove\", e.ondropmove), /^(pointer|center)$/.test(e.overlap) ? t.options.drop.overlap = e.overlap : a.default.number(e.overlap) && (t.options.drop.overlap = Math.max(Math.min(1, e.overlap), 0)), \"accept\" in e && (t.options.drop.accept = e.accept), \"checker\" in e && (t.options.drop.checker = e.checker), t;\n          }\n\n          if (a.default.bool(e)) return t.options.drop.enabled = e, t;\n          return t.options.drop;\n        }(this, t);\n      }, r.prototype.dropCheck = function (t, e, n, r, o, i) {\n        return function (t, e, n, r, o, i, s) {\n          var l = !1;\n          if (!(s = s || t.getRect(i))) return !!t.options.drop.checker && t.options.drop.checker(e, n, l, t, i, r, o);\n          var u = t.options.drop.overlap;\n\n          if (\"pointer\" === u) {\n            var c = (0, z.default)(r, o, \"drag\"),\n                f = L.getPageXY(e);\n            f.x += c.x, f.y += c.y;\n            var d = f.x > s.left && f.x < s.right,\n                p = f.y > s.top && f.y < s.bottom;\n            l = d && p;\n          }\n\n          var v = r.getRect(o);\n\n          if (v && \"center\" === u) {\n            var h = v.left + v.width / 2,\n                g = v.top + v.height / 2;\n            l = h >= s.left && h <= s.right && g >= s.top && g <= s.bottom;\n          }\n\n          if (v && a.default.number(u)) {\n            var y = Math.max(0, Math.min(s.right, v.right) - Math.max(s.left, v.left)) * Math.max(0, Math.min(s.bottom, v.bottom) - Math.max(s.top, v.top)) / (v.width * v.height);\n            l = y >= u;\n          }\n\n          t.options.drop.checker && (l = t.options.drop.checker(e, n, l, t, i, r, o));\n          return l;\n        }(this, t, e, n, r, o, i);\n      }, n.dynamicDrop = function (e) {\n        return a.default.bool(e) ? (t.dynamicDrop = e, n) : t.dynamicDrop;\n      }, (0, k.default)(e.phaselessTypes, {\n        dragenter: !0,\n        dragleave: !0,\n        dropactivate: !0,\n        dropdeactivate: !0,\n        dropmove: !0,\n        drop: !0\n      }), e.methodDict.drop = \"dropzone\", t.dynamicDrop = !1, o.actions.drop = gt.defaults;\n    },\n    listeners: {\n      \"interactions:before-action-start\": function interactionsBeforeActionStart(t) {\n        var e = t.interaction;\n        \"drag\" === e.prepared.name && (e.dropState = {\n          cur: {\n            dropzone: null,\n            element: null\n          },\n          prev: {\n            dropzone: null,\n            element: null\n          },\n          rejected: null,\n          events: null,\n          activeDrops: []\n        });\n      },\n      \"interactions:after-action-start\": function interactionsAfterActionStart(t, e) {\n        var n = t.interaction,\n            r = (t.event, t.iEvent);\n\n        if (\"drag\" === n.prepared.name) {\n          var o = n.dropState;\n          o.activeDrops = null, o.events = null, o.activeDrops = ft(e, n.element), o.events = pt(n, 0, r), o.events.activate && (ct(o.activeDrops, o.events.activate), e.fire(\"actions/drop:start\", {\n            interaction: n,\n            dragEvent: r\n          }));\n        }\n      },\n      \"interactions:action-move\": ht,\n      \"interactions:action-end\": ht,\n      \"interactions:after-action-move\": function interactionsAfterActionMove(t, e) {\n        var n = t.interaction,\n            r = t.iEvent;\n        \"drag\" === n.prepared.name && (vt(n, n.dropState.events), e.fire(\"actions/drop:move\", {\n          interaction: n,\n          dragEvent: r\n        }), n.dropState.events = {});\n      },\n      \"interactions:after-action-end\": function interactionsAfterActionEnd(t, e) {\n        var n = t.interaction,\n            r = t.iEvent;\n        \"drag\" === n.prepared.name && (vt(n, n.dropState.events), e.fire(\"actions/drop:end\", {\n          interaction: n,\n          dragEvent: r\n        }));\n      },\n      \"interactions:stop\": function interactionsStop(t) {\n        var e = t.interaction;\n\n        if (\"drag\" === e.prepared.name) {\n          var n = e.dropState;\n          n && (n.activeDrops = null, n.events = null, n.cur.dropzone = null, n.cur.element = null, n.prev.dropzone = null, n.prev.element = null, n.rejected = !1);\n        }\n      }\n    },\n    getActiveDrops: ft,\n    getDrop: dt,\n    getDropEvents: pt,\n    fireDropEvents: vt,\n    defaults: {\n      enabled: !1,\n      accept: null,\n      overlap: \"pointer\"\n    }\n  },\n      yt = gt;\n  ut.default = yt;\n  var mt = {};\n\n  function bt(t) {\n    var e = t.interaction,\n        n = t.iEvent,\n        r = t.phase;\n\n    if (\"gesture\" === e.prepared.name) {\n      var o = e.pointers.map(function (t) {\n        return t.pointer;\n      }),\n          i = \"start\" === r,\n          s = \"end\" === r,\n          l = e.interactable.options.deltaSource;\n      if (n.touches = [o[0], o[1]], i) n.distance = L.touchDistance(o, l), n.box = L.touchBBox(o), n.scale = 1, n.ds = 0, n.angle = L.touchAngle(o, l), n.da = 0, e.gesture.startDistance = n.distance, e.gesture.startAngle = n.angle;else if (s) {\n        var u = e.prevEvent;\n        n.distance = u.distance, n.box = u.box, n.scale = u.scale, n.ds = 0, n.angle = u.angle, n.da = 0;\n      } else n.distance = L.touchDistance(o, l), n.box = L.touchBBox(o), n.scale = n.distance / e.gesture.startDistance, n.angle = L.touchAngle(o, l), n.ds = n.scale - e.gesture.scale, n.da = n.angle - e.gesture.angle;\n      e.gesture.distance = n.distance, e.gesture.angle = n.angle, a.default.number(n.scale) && n.scale !== 1 / 0 && !isNaN(n.scale) && (e.gesture.scale = n.scale);\n    }\n  }\n\n  Object.defineProperty(mt, \"__esModule\", {\n    value: !0\n  }), mt.default = void 0;\n  var xt = {\n    id: \"actions/gesture\",\n    before: [\"actions/drag\", \"actions/resize\"],\n    install: function install(t) {\n      var e = t.actions,\n          n = t.Interactable,\n          r = t.defaults;\n      n.prototype.gesturable = function (t) {\n        return a.default.object(t) ? (this.options.gesture.enabled = !1 !== t.enabled, this.setPerAction(\"gesture\", t), this.setOnEvents(\"gesture\", t), this) : a.default.bool(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture;\n      }, e.map.gesture = xt, e.methodDict.gesture = \"gesturable\", r.actions.gesture = xt.defaults;\n    },\n    listeners: {\n      \"interactions:action-start\": bt,\n      \"interactions:action-move\": bt,\n      \"interactions:action-end\": bt,\n      \"interactions:new\": function interactionsNew(t) {\n        t.interaction.gesture = {\n          angle: 0,\n          distance: 0,\n          scale: 1,\n          startAngle: 0,\n          startDistance: 0\n        };\n      },\n      \"auto-start:check\": function autoStartCheck(t) {\n        if (!(t.interaction.pointers.length < 2)) {\n          var e = t.interactable.options.gesture;\n          if (e && e.enabled) return t.action = {\n            name: \"gesture\"\n          }, !1;\n        }\n      }\n    },\n    defaults: {},\n    getCursor: function getCursor() {\n      return \"\";\n    }\n  },\n      wt = xt;\n  mt.default = wt;\n  var _t = {};\n\n  function St(t, e, n, r, o, i, s) {\n    if (!e) return !1;\n\n    if (!0 === e) {\n      var l = a.default.number(i.width) ? i.width : i.right - i.left,\n          u = a.default.number(i.height) ? i.height : i.bottom - i.top;\n      if (s = Math.min(s, Math.abs((\"left\" === t || \"right\" === t ? l : u) / 2)), l < 0 && (\"left\" === t ? t = \"right\" : \"right\" === t && (t = \"left\")), u < 0 && (\"top\" === t ? t = \"bottom\" : \"bottom\" === t && (t = \"top\")), \"left\" === t) return n.x < (l >= 0 ? i.left : i.right) + s;\n      if (\"top\" === t) return n.y < (u >= 0 ? i.top : i.bottom) + s;\n      if (\"right\" === t) return n.x > (l >= 0 ? i.right : i.left) - s;\n      if (\"bottom\" === t) return n.y > (u >= 0 ? i.bottom : i.top) - s;\n    }\n\n    return !!a.default.element(r) && (a.default.element(e) ? e === r : S.matchesUpTo(r, e, o));\n  }\n\n  function Pt(t) {\n    var e = t.iEvent,\n        n = t.interaction;\n\n    if (\"resize\" === n.prepared.name && n.resizeAxes) {\n      var r = e;\n      n.interactable.options.resize.square ? (\"y\" === n.resizeAxes ? r.delta.x = r.delta.y : r.delta.y = r.delta.x, r.axes = \"xy\") : (r.axes = n.resizeAxes, \"x\" === n.resizeAxes ? r.delta.y = 0 : \"y\" === n.resizeAxes && (r.delta.x = 0));\n    }\n  }\n\n  Object.defineProperty(_t, \"__esModule\", {\n    value: !0\n  }), _t.default = void 0;\n  var Ot = {\n    id: \"actions/resize\",\n    before: [\"actions/drag\"],\n    install: function install(t) {\n      var e = t.actions,\n          n = t.browser,\n          r = t.Interactable,\n          o = t.defaults;\n      Ot.cursors = function (t) {\n        return t.isIe9 ? {\n          x: \"e-resize\",\n          y: \"s-resize\",\n          xy: \"se-resize\",\n          top: \"n-resize\",\n          left: \"w-resize\",\n          bottom: \"s-resize\",\n          right: \"e-resize\",\n          topleft: \"se-resize\",\n          bottomright: \"se-resize\",\n          topright: \"ne-resize\",\n          bottomleft: \"ne-resize\"\n        } : {\n          x: \"ew-resize\",\n          y: \"ns-resize\",\n          xy: \"nwse-resize\",\n          top: \"ns-resize\",\n          left: \"ew-resize\",\n          bottom: \"ns-resize\",\n          right: \"ew-resize\",\n          topleft: \"nwse-resize\",\n          bottomright: \"nwse-resize\",\n          topright: \"nesw-resize\",\n          bottomleft: \"nesw-resize\"\n        };\n      }(n), Ot.defaultMargin = n.supportsTouch || n.supportsPointerEvent ? 20 : 10, r.prototype.resizable = function (e) {\n        return function (t, e, n) {\n          if (a.default.object(e)) return t.options.resize.enabled = !1 !== e.enabled, t.setPerAction(\"resize\", e), t.setOnEvents(\"resize\", e), a.default.string(e.axis) && /^x$|^y$|^xy$/.test(e.axis) ? t.options.resize.axis = e.axis : null === e.axis && (t.options.resize.axis = n.defaults.actions.resize.axis), a.default.bool(e.preserveAspectRatio) ? t.options.resize.preserveAspectRatio = e.preserveAspectRatio : a.default.bool(e.square) && (t.options.resize.square = e.square), t;\n          if (a.default.bool(e)) return t.options.resize.enabled = e, t;\n          return t.options.resize;\n        }(this, e, t);\n      }, e.map.resize = Ot, e.methodDict.resize = \"resizable\", o.actions.resize = Ot.defaults;\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        t.interaction.resizeAxes = \"xy\";\n      },\n      \"interactions:action-start\": function interactionsActionStart(t) {\n        !function (t) {\n          var e = t.iEvent,\n              n = t.interaction;\n\n          if (\"resize\" === n.prepared.name && n.prepared.edges) {\n            var r = e,\n                o = n.rect;\n            n._rects = {\n              start: (0, k.default)({}, o),\n              corrected: (0, k.default)({}, o),\n              previous: (0, k.default)({}, o),\n              delta: {\n                left: 0,\n                right: 0,\n                width: 0,\n                top: 0,\n                bottom: 0,\n                height: 0\n              }\n            }, r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;\n          }\n        }(t), Pt(t);\n      },\n      \"interactions:action-move\": function interactionsActionMove(t) {\n        !function (t) {\n          var e = t.iEvent,\n              n = t.interaction;\n\n          if (\"resize\" === n.prepared.name && n.prepared.edges) {\n            var r = e,\n                o = n.interactable.options.resize.invert,\n                i = \"reposition\" === o || \"negate\" === o,\n                a = n.rect,\n                s = n._rects,\n                l = s.start,\n                u = s.corrected,\n                c = s.delta,\n                f = s.previous;\n\n            if ((0, k.default)(f, u), i) {\n              if ((0, k.default)(u, a), \"reposition\" === o) {\n                if (u.top > u.bottom) {\n                  var d = u.top;\n                  u.top = u.bottom, u.bottom = d;\n                }\n\n                if (u.left > u.right) {\n                  var p = u.left;\n                  u.left = u.right, u.right = p;\n                }\n              }\n            } else u.top = Math.min(a.top, l.bottom), u.bottom = Math.max(a.bottom, l.top), u.left = Math.min(a.left, l.right), u.right = Math.max(a.right, l.left);\n\n            for (var v in u.width = u.right - u.left, u.height = u.bottom - u.top, u) c[v] = u[v] - f[v];\n\n            r.edges = n.prepared.edges, r.rect = u, r.deltaRect = c;\n          }\n        }(t), Pt(t);\n      },\n      \"interactions:action-end\": function interactionsActionEnd(t) {\n        var e = t.iEvent,\n            n = t.interaction;\n\n        if (\"resize\" === n.prepared.name && n.prepared.edges) {\n          var r = e;\n          r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;\n        }\n      },\n      \"auto-start:check\": function autoStartCheck(t) {\n        var e = t.interaction,\n            n = t.interactable,\n            r = t.element,\n            o = t.rect,\n            i = t.buttons;\n\n        if (o) {\n          var s = (0, k.default)({}, e.coords.cur.page),\n              l = n.options.resize;\n\n          if (l && l.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (i & l.mouseButtons))) {\n            if (a.default.object(l.edges)) {\n              var u = {\n                left: !1,\n                right: !1,\n                top: !1,\n                bottom: !1\n              };\n\n              for (var c in u) u[c] = St(c, l.edges[c], s, e._latestPointer.eventTarget, r, o, l.margin || Ot.defaultMargin);\n\n              u.left = u.left && !u.right, u.top = u.top && !u.bottom, (u.left || u.right || u.top || u.bottom) && (t.action = {\n                name: \"resize\",\n                edges: u\n              });\n            } else {\n              var f = \"y\" !== l.axis && s.x > o.right - Ot.defaultMargin,\n                  d = \"x\" !== l.axis && s.y > o.bottom - Ot.defaultMargin;\n              (f || d) && (t.action = {\n                name: \"resize\",\n                axes: (f ? \"x\" : \"\") + (d ? \"y\" : \"\")\n              });\n            }\n\n            return !t.action && void 0;\n          }\n        }\n      }\n    },\n    defaults: {\n      square: !1,\n      preserveAspectRatio: !1,\n      axis: \"xy\",\n      margin: NaN,\n      edges: null,\n      invert: \"none\"\n    },\n    cursors: null,\n    getCursor: function getCursor(t) {\n      var e = t.edges,\n          n = t.axis,\n          r = t.name,\n          o = Ot.cursors,\n          i = null;\n      if (n) i = o[r + n];else if (e) {\n        for (var a = \"\", s = [\"top\", \"bottom\", \"left\", \"right\"], l = 0; l < s.length; l++) {\n          var u = s[l];\n          e[u] && (a += u);\n        }\n\n        i = o[a];\n      }\n      return i;\n    },\n    defaultMargin: null\n  },\n      Et = Ot;\n  _t.default = Et;\n  var Tt = {};\n  Object.defineProperty(Tt, \"__esModule\", {\n    value: !0\n  }), Tt.default = void 0;\n  var Mt = {\n    id: \"actions\",\n    install: function install(t) {\n      t.usePlugin(mt.default), t.usePlugin(_t.default), t.usePlugin(f.default), t.usePlugin(ut.default);\n    }\n  };\n  Tt.default = Mt;\n  var jt = {};\n  Object.defineProperty(jt, \"__esModule\", {\n    value: !0\n  }), jt.default = void 0;\n  jt.default = {};\n  var kt = {};\n  Object.defineProperty(kt, \"__esModule\", {\n    value: !0\n  }), kt.default = void 0;\n  var It,\n      Dt,\n      At = 0;\n  var zt = {\n    request: function request(t) {\n      return It(t);\n    },\n    cancel: function cancel(t) {\n      return Dt(t);\n    },\n    init: function init(t) {\n      if (It = t.requestAnimationFrame, Dt = t.cancelAnimationFrame, !It) for (var e = [\"ms\", \"moz\", \"webkit\", \"o\"], n = 0; n < e.length; n++) {\n        var r = e[n];\n        It = t[\"\".concat(r, \"RequestAnimationFrame\")], Dt = t[\"\".concat(r, \"CancelAnimationFrame\")] || t[\"\".concat(r, \"CancelRequestAnimationFrame\")];\n      }\n      It || (It = function It(t) {\n        var e = Date.now(),\n            n = Math.max(0, 16 - (e - At)),\n            r = setTimeout(function () {\n          t(e + n);\n        }, n);\n        return At = e + n, r;\n      }, Dt = function Dt(t) {\n        return clearTimeout(t);\n      });\n    }\n  };\n  kt.default = zt;\n  var Ct = {};\n  Object.defineProperty(Ct, \"__esModule\", {\n    value: !0\n  }), Ct.getContainer = Ft, Ct.getScroll = Xt, Ct.getScrollSize = function (t) {\n    a.default.window(t) && (t = window.document.body);\n    return {\n      x: t.scrollWidth,\n      y: t.scrollHeight\n    };\n  }, Ct.getScrollSizeDelta = function (t, e) {\n    var n = t.interaction,\n        r = t.element,\n        o = n && n.interactable.options[n.prepared.name].autoScroll;\n    if (!o || !o.enabled) return e(), {\n      x: 0,\n      y: 0\n    };\n    var i = Ft(o.container, n.interactable, r),\n        a = Xt(i);\n    e();\n    var s = Xt(i);\n    return {\n      x: s.x - a.x,\n      y: s.y - a.y\n    };\n  }, Ct.default = void 0;\n  var Rt = {\n    defaults: {\n      enabled: !1,\n      margin: 60,\n      container: null,\n      speed: 300\n    },\n    now: Date.now,\n    interaction: null,\n    i: 0,\n    x: 0,\n    y: 0,\n    isScrolling: !1,\n    prevTime: 0,\n    margin: 0,\n    speed: 0,\n    start: function start(t) {\n      Rt.isScrolling = !0, kt.default.cancel(Rt.i), t.autoScroll = Rt, Rt.interaction = t, Rt.prevTime = Rt.now(), Rt.i = kt.default.request(Rt.scroll);\n    },\n    stop: function stop() {\n      Rt.isScrolling = !1, Rt.interaction && (Rt.interaction.autoScroll = null), kt.default.cancel(Rt.i);\n    },\n    scroll: function scroll() {\n      var t = Rt.interaction,\n          e = t.interactable,\n          n = t.element,\n          r = t.prepared.name,\n          o = e.options[r].autoScroll,\n          i = Ft(o.container, e, n),\n          s = Rt.now(),\n          l = (s - Rt.prevTime) / 1e3,\n          u = o.speed * l;\n\n      if (u >= 1) {\n        var c = {\n          x: Rt.x * u,\n          y: Rt.y * u\n        };\n\n        if (c.x || c.y) {\n          var f = Xt(i);\n          a.default.window(i) ? i.scrollBy(c.x, c.y) : i && (i.scrollLeft += c.x, i.scrollTop += c.y);\n          var d = Xt(i),\n              p = {\n            x: d.x - f.x,\n            y: d.y - f.y\n          };\n          (p.x || p.y) && e.fire({\n            type: \"autoscroll\",\n            target: n,\n            interactable: e,\n            delta: p,\n            interaction: t,\n            container: i\n          });\n        }\n\n        Rt.prevTime = s;\n      }\n\n      Rt.isScrolling && (kt.default.cancel(Rt.i), Rt.i = kt.default.request(Rt.scroll));\n    },\n    check: function check(t, e) {\n      var n = t.options;\n      return n[e].autoScroll && n[e].autoScroll.enabled;\n    },\n    onInteractionMove: function onInteractionMove(t) {\n      var e = t.interaction,\n          n = t.pointer;\n      if (e.interacting() && Rt.check(e.interactable, e.prepared.name)) if (e.simulation) Rt.x = Rt.y = 0;else {\n        var r,\n            o,\n            i,\n            s,\n            l = e.interactable,\n            u = e.element,\n            c = e.prepared.name,\n            f = l.options[c].autoScroll,\n            d = Ft(f.container, l, u);\n        if (a.default.window(d)) s = n.clientX < Rt.margin, r = n.clientY < Rt.margin, o = n.clientX > d.innerWidth - Rt.margin, i = n.clientY > d.innerHeight - Rt.margin;else {\n          var p = S.getElementClientRect(d);\n          s = n.clientX < p.left + Rt.margin, r = n.clientY < p.top + Rt.margin, o = n.clientX > p.right - Rt.margin, i = n.clientY > p.bottom - Rt.margin;\n        }\n        Rt.x = o ? 1 : s ? -1 : 0, Rt.y = i ? 1 : r ? -1 : 0, Rt.isScrolling || (Rt.margin = f.margin, Rt.speed = f.speed, Rt.start(e));\n      }\n    }\n  };\n\n  function Ft(t, n, r) {\n    return (a.default.string(t) ? (0, I.getStringOptionResult)(t, n, r) : t) || (0, e.getWindow)(r);\n  }\n\n  function Xt(t) {\n    return a.default.window(t) && (t = window.document.body), {\n      x: t.scrollLeft,\n      y: t.scrollTop\n    };\n  }\n\n  var Yt = {\n    id: \"auto-scroll\",\n    install: function install(t) {\n      var e = t.defaults,\n          n = t.actions;\n      t.autoScroll = Rt, Rt.now = function () {\n        return t.now();\n      }, n.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = Rt.defaults;\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        t.interaction.autoScroll = null;\n      },\n      \"interactions:destroy\": function interactionsDestroy(t) {\n        t.interaction.autoScroll = null, Rt.stop(), Rt.interaction && (Rt.interaction = null);\n      },\n      \"interactions:stop\": Rt.stop,\n      \"interactions:action-move\": function interactionsActionMove(t) {\n        return Rt.onInteractionMove(t);\n      }\n    }\n  };\n  Ct.default = Yt;\n  var Wt = {};\n  Object.defineProperty(Wt, \"__esModule\", {\n    value: !0\n  }), Wt.warnOnce = function (t, n) {\n    var r = !1;\n    return function () {\n      return r || (e.default.window.console.warn(n), r = !0), t.apply(this, arguments);\n    };\n  }, Wt.copyAction = function (t, e) {\n    return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;\n  };\n  var Lt = {};\n\n  function Bt(t) {\n    return a.default.bool(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor;\n  }\n\n  function Ut(t) {\n    return a.default.func(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker;\n  }\n\n  Object.defineProperty(Lt, \"__esModule\", {\n    value: !0\n  }), Lt.default = void 0;\n  var Vt = {\n    id: \"auto-start/interactableMethods\",\n    install: function install(t) {\n      var e = t.Interactable;\n      e.prototype.getAction = function (e, n, r, o) {\n        var i = function (t, e, n, r, o) {\n          var i = t.getRect(r),\n              a = e.buttons || {\n            0: 1,\n            1: 4,\n            3: 8,\n            4: 16\n          }[e.button],\n              s = {\n            action: null,\n            interactable: t,\n            interaction: n,\n            element: r,\n            rect: i,\n            buttons: a\n          };\n          return o.fire(\"auto-start:check\", s), s.action;\n        }(this, n, r, o, t);\n\n        return this.options.actionChecker ? this.options.actionChecker(e, n, i, this, o, r) : i;\n      }, e.prototype.ignoreFrom = (0, Wt.warnOnce)(function (t) {\n        return this._backCompatOption(\"ignoreFrom\", t);\n      }, \"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).\"), e.prototype.allowFrom = (0, Wt.warnOnce)(function (t) {\n        return this._backCompatOption(\"allowFrom\", t);\n      }, \"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).\"), e.prototype.actionChecker = Ut, e.prototype.styleCursor = Bt;\n    }\n  };\n  Lt.default = Vt;\n  var qt = {};\n\n  function Nt(t, e, n, r, o) {\n    return e.testIgnoreAllow(e.options[t.name], n, r) && e.options[t.name].enabled && Kt(e, n, t, o) ? t : null;\n  }\n\n  function $t(t, e, n, r, o, i, a) {\n    for (var s = 0, l = r.length; s < l; s++) {\n      var u = r[s],\n          c = o[s],\n          f = u.getAction(e, n, t, c);\n\n      if (f) {\n        var d = Nt(f, u, c, i, a);\n        if (d) return {\n          action: d,\n          interactable: u,\n          element: c\n        };\n      }\n    }\n\n    return {\n      action: null,\n      interactable: null,\n      element: null\n    };\n  }\n\n  function Gt(t, e, n, r, o) {\n    var i = [],\n        s = [],\n        l = r;\n\n    function u(t) {\n      i.push(t), s.push(l);\n    }\n\n    for (; a.default.element(l);) {\n      i = [], s = [], o.interactables.forEachMatch(l, u);\n      var c = $t(t, e, n, i, s, r, o);\n      if (c.action && !c.interactable.options[c.action.name].manualStart) return c;\n      l = S.parentNode(l);\n    }\n\n    return {\n      action: null,\n      interactable: null,\n      element: null\n    };\n  }\n\n  function Ht(t, e, n) {\n    var r = e.action,\n        o = e.interactable,\n        i = e.element;\n    r = r || {\n      name: null\n    }, t.interactable = o, t.element = i, (0, Wt.copyAction)(t.prepared, r), t.rect = o && r.name ? o.getRect(i) : null, Qt(t, n), n.fire(\"autoStart:prepared\", {\n      interaction: t\n    });\n  }\n\n  function Kt(t, e, n, r) {\n    var o = t.options,\n        i = o[n.name].max,\n        a = o[n.name].maxPerElement,\n        s = r.autoStart.maxInteractions,\n        l = 0,\n        u = 0,\n        c = 0;\n    if (!(i && a && s)) return !1;\n\n    for (var f = 0; f < r.interactions.list.length; f++) {\n      var d = r.interactions.list[f],\n          p = d.prepared.name;\n\n      if (d.interacting()) {\n        if (++l >= s) return !1;\n\n        if (d.interactable === t) {\n          if ((u += p === n.name ? 1 : 0) >= i) return !1;\n          if (d.element === e && (c++, p === n.name && c >= a)) return !1;\n        }\n      }\n    }\n\n    return s > 0;\n  }\n\n  function Zt(t, e) {\n    return a.default.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;\n  }\n\n  function Jt(t, e, n) {\n    var r = n.autoStart.cursorElement;\n    r && r !== t && (r.style.cursor = \"\"), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, n.autoStart.cursorElement = e ? t : null;\n  }\n\n  function Qt(t, e) {\n    var n = t.interactable,\n        r = t.element,\n        o = t.prepared;\n\n    if (\"mouse\" === t.pointerType && n && n.options.styleCursor) {\n      var i = \"\";\n\n      if (o.name) {\n        var s = n.options[o.name].cursorChecker;\n        i = a.default.func(s) ? s(o, n, r, t._interacting) : e.actions.map[o.name].getCursor(o);\n      }\n\n      Jt(t.element, i || \"\", e);\n    } else e.autoStart.cursorElement && Jt(e.autoStart.cursorElement, \"\", e);\n  }\n\n  Object.defineProperty(qt, \"__esModule\", {\n    value: !0\n  }), qt.default = void 0;\n  var te = {\n    id: \"auto-start/base\",\n    before: [\"actions\"],\n    install: function install(t) {\n      var e = t.interactStatic,\n          n = t.defaults;\n      t.usePlugin(Lt.default), n.base.actionChecker = null, n.base.styleCursor = !0, (0, k.default)(n.perAction, {\n        manualStart: !1,\n        max: 1 / 0,\n        maxPerElement: 1,\n        allowFrom: null,\n        ignoreFrom: null,\n        mouseButtons: 1\n      }), e.maxInteractions = function (e) {\n        return Zt(e, t);\n      }, t.autoStart = {\n        maxInteractions: 1 / 0,\n        withinInteractionLimit: Kt,\n        cursorElement: null\n      };\n    },\n    listeners: {\n      \"interactions:down\": function interactionsDown(t, e) {\n        var n = t.interaction,\n            r = t.pointer,\n            o = t.event,\n            i = t.eventTarget;\n        n.interacting() || Ht(n, Gt(n, r, o, i, e), e);\n      },\n      \"interactions:move\": function interactionsMove(t, e) {\n        !function (t, e) {\n          var n = t.interaction,\n              r = t.pointer,\n              o = t.event,\n              i = t.eventTarget;\n          \"mouse\" !== n.pointerType || n.pointerIsDown || n.interacting() || Ht(n, Gt(n, r, o, i, e), e);\n        }(t, e), function (t, e) {\n          var n = t.interaction;\n\n          if (n.pointerIsDown && !n.interacting() && n.pointerWasMoved && n.prepared.name) {\n            e.fire(\"autoStart:before-start\", t);\n            var r = n.interactable,\n                o = n.prepared.name;\n            o && r && (r.options[o].manualStart || !Kt(r, n.element, n.prepared, e) ? n.stop() : (n.start(n.prepared, r, n.element), Qt(n, e)));\n          }\n        }(t, e);\n      },\n      \"interactions:stop\": function interactionsStop(t, e) {\n        var n = t.interaction,\n            r = n.interactable;\n        r && r.options.styleCursor && Jt(n.element, \"\", e);\n      }\n    },\n    maxInteractions: Zt,\n    withinInteractionLimit: Kt,\n    validateAction: Nt\n  };\n  qt.default = te;\n  var ee = {};\n  Object.defineProperty(ee, \"__esModule\", {\n    value: !0\n  }), ee.default = void 0;\n  var ne = {\n    id: \"auto-start/dragAxis\",\n    listeners: {\n      \"autoStart:before-start\": function autoStartBeforeStart(t, e) {\n        var n = t.interaction,\n            r = t.eventTarget,\n            o = t.dx,\n            i = t.dy;\n\n        if (\"drag\" === n.prepared.name) {\n          var s = Math.abs(o),\n              l = Math.abs(i),\n              u = n.interactable.options.drag,\n              c = u.startAxis,\n              f = s > l ? \"x\" : s < l ? \"y\" : \"xy\";\n\n          if (n.prepared.axis = \"start\" === u.lockAxis ? f[0] : u.lockAxis, \"xy\" !== f && \"xy\" !== c && c !== f) {\n            n.prepared.name = null;\n\n            for (var d = r, p = function p(t) {\n              if (t !== n.interactable) {\n                var o = n.interactable.options.drag;\n\n                if (!o.manualStart && t.testIgnoreAllow(o, d, r)) {\n                  var i = t.getAction(n.downPointer, n.downEvent, n, d);\n                  if (i && \"drag\" === i.name && function (t, e) {\n                    if (!e) return !1;\n                    var n = e.options.drag.startAxis;\n                    return \"xy\" === t || \"xy\" === n || n === t;\n                  }(f, t) && qt.default.validateAction(i, t, d, r, e)) return t;\n                }\n              }\n            }; a.default.element(d);) {\n              var v = e.interactables.forEachMatch(d, p);\n\n              if (v) {\n                n.prepared.name = \"drag\", n.interactable = v, n.element = d;\n                break;\n              }\n\n              d = (0, S.parentNode)(d);\n            }\n          }\n        }\n      }\n    }\n  };\n  ee.default = ne;\n  var re = {};\n\n  function oe(t) {\n    var e = t.prepared && t.prepared.name;\n    if (!e) return null;\n    var n = t.interactable.options;\n    return n[e].hold || n[e].delay;\n  }\n\n  Object.defineProperty(re, \"__esModule\", {\n    value: !0\n  }), re.default = void 0;\n  var ie = {\n    id: \"auto-start/hold\",\n    install: function install(t) {\n      var e = t.defaults;\n      t.usePlugin(qt.default), e.perAction.hold = 0, e.perAction.delay = 0;\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        t.interaction.autoStartHoldTimer = null;\n      },\n      \"autoStart:prepared\": function autoStartPrepared(t) {\n        var e = t.interaction,\n            n = oe(e);\n        n > 0 && (e.autoStartHoldTimer = setTimeout(function () {\n          e.start(e.prepared, e.interactable, e.element);\n        }, n));\n      },\n      \"interactions:move\": function interactionsMove(t) {\n        var e = t.interaction,\n            n = t.duplicate;\n        e.pointerWasMoved && !n && clearTimeout(e.autoStartHoldTimer);\n      },\n      \"autoStart:before-start\": function autoStartBeforeStart(t) {\n        var e = t.interaction;\n        oe(e) > 0 && (e.prepared.name = null);\n      }\n    },\n    getHoldDuration: oe\n  };\n  re.default = ie;\n  var ae = {};\n  Object.defineProperty(ae, \"__esModule\", {\n    value: !0\n  }), ae.default = void 0;\n  var se = {\n    id: \"auto-start\",\n    install: function install(t) {\n      t.usePlugin(qt.default), t.usePlugin(re.default), t.usePlugin(ee.default);\n    }\n  };\n  ae.default = se;\n  var le = {};\n  Object.defineProperty(le, \"__esModule\", {\n    value: !0\n  }), le.default = void 0;\n  le.default = {};\n  var ue = {};\n\n  function ce(t) {\n    return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : a.default.bool(t) ? (this.options.preventDefault = t ? \"always\" : \"never\", this) : this.options.preventDefault;\n  }\n\n  function fe(t) {\n    var e = t.interaction,\n        n = t.event;\n    e.interactable && e.interactable.checkAndPreventDefault(n);\n  }\n\n  function de(t) {\n    var n = t.Interactable;\n    n.prototype.preventDefault = ce, n.prototype.checkAndPreventDefault = function (n) {\n      return function (t, n, r) {\n        var o = t.options.preventDefault;\n        if (\"never\" !== o) if (\"always\" !== o) {\n          if (n.events.supportsPassive && /^touch(start|move)$/.test(r.type)) {\n            var i = (0, e.getWindow)(r.target).document,\n                s = n.getDocOptions(i);\n            if (!s || !s.events || !1 !== s.events.passive) return;\n          }\n\n          /^(mouse|pointer|touch)*(down|start)/i.test(r.type) || a.default.element(r.target) && (0, S.matchesSelector)(r.target, \"input,select,textarea,[contenteditable=true],[contenteditable=true] *\") || r.preventDefault();\n        } else r.preventDefault();\n      }(this, t, n);\n    }, t.interactions.docEvents.push({\n      type: \"dragstart\",\n      listener: function listener(e) {\n        for (var n = 0; n < t.interactions.list.length; n++) {\n          var r = t.interactions.list[n];\n          if (r.element && (r.element === e.target || (0, S.nodeContains)(r.element, e.target))) return void r.interactable.checkAndPreventDefault(e);\n        }\n      }\n    });\n  }\n\n  Object.defineProperty(ue, \"__esModule\", {\n    value: !0\n  }), ue.install = de, ue.default = void 0;\n  var pe = {\n    id: \"core/interactablePreventDefault\",\n    install: de,\n    listeners: [\"down\", \"move\", \"up\", \"cancel\"].reduce(function (t, e) {\n      return t[\"interactions:\".concat(e)] = fe, t;\n    }, {})\n  };\n  ue.default = pe;\n  var ve,\n      he = {};\n\n  function ge(t) {\n    return function (t) {\n      if (Array.isArray(t)) return ye(t);\n    }(t) || function (t) {\n      if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t);\n    }(t) || function (t, e) {\n      if (!t) return;\n      if (\"string\" == typeof t) return ye(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      \"Object\" === n && t.constructor && (n = t.constructor.name);\n      if (\"Map\" === n || \"Set\" === n) return Array.from(t);\n      if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ye(t, e);\n    }(t) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function ye(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  Object.defineProperty(he, \"__esModule\", {\n    value: !0\n  }), he.default = void 0, function (t) {\n    t.touchAction = \"touchAction\", t.boxSizing = \"boxSizing\", t.noListeners = \"noListeners\";\n  }(ve || (ve = {}));\n  var me = {\n    touchAction: \"https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action\",\n    boxSizing: \"https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing\"\n  };\n  var be = [{\n    name: ve.touchAction,\n    perform: function perform(t) {\n      return !function (t, e, n) {\n        var r = t;\n\n        for (; a.default.element(r);) {\n          if (xe(r, e, n)) return !0;\n          r = (0, S.parentNode)(r);\n        }\n\n        return !1;\n      }(t.element, \"touchAction\", /pan-|pinch|none/);\n    },\n    getInfo: function getInfo(t) {\n      return [t.element, me.touchAction];\n    },\n    text: 'Consider adding CSS \"touch-action: none\" to this element\\n'\n  }, {\n    name: ve.boxSizing,\n    perform: function perform(t) {\n      var e = t.element;\n      return \"resize\" === t.prepared.name && e instanceof g.default.HTMLElement && !xe(e, \"boxSizing\", /border-box/);\n    },\n    text: 'Consider adding CSS \"box-sizing: border-box\" to this resizable element',\n    getInfo: function getInfo(t) {\n      return [t.element, me.boxSizing];\n    }\n  }, {\n    name: ve.noListeners,\n    perform: function perform(t) {\n      var e = t.prepared.name;\n      return !(t.interactable.events.types[\"\".concat(e, \"move\")] || []).length;\n    },\n    getInfo: function getInfo(t) {\n      return [t.prepared.name, t.interactable];\n    },\n    text: \"There are no listeners set for this action\"\n  }];\n\n  function xe(t, n, r) {\n    var o = t.style[n] || e.default.window.getComputedStyle(t)[n];\n    return r.test((o || \"\").toString());\n  }\n\n  var we = \"dev-tools\",\n      _e = {\n    id: we,\n    install: function install(t) {\n      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          n = e.logger,\n          r = t.Interactable,\n          o = t.defaults;\n      t.logger = n || console, o.base.devTools = {\n        ignore: {}\n      }, r.prototype.devTools = function (t) {\n        return t ? ((0, k.default)(this.options.devTools, t), this) : this.options.devTools;\n      };\n    },\n    listeners: {\n      \"interactions:action-start\": function interactionsActionStart(t, e) {\n        for (var n = t.interaction, r = 0; r < be.length; r++) {\n          var o,\n              i = be[r],\n              a = n.interactable && n.interactable.options;\n          if (!(a && a.devTools && a.devTools.ignore[i.name]) && i.perform(n)) (o = e.logger).warn.apply(o, [\"[interact.js] \" + i.text].concat(ge(i.getInfo(n))));\n        }\n      }\n    },\n    checks: be,\n    CheckName: ve,\n    links: me,\n    prefix: \"[interact.js] \"\n  };\n  he.default = _e;\n  var Se = {};\n  Object.defineProperty(Se, \"__esModule\", {\n    value: !0\n  }), Se.default = void 0;\n  Se.default = {};\n  var Pe = {};\n  Object.defineProperty(Pe, \"__esModule\", {\n    value: !0\n  }), Pe.default = function t(e) {\n    var n = {};\n\n    for (var r in e) {\n      var o = e[r];\n      a.default.plainObject(o) ? n[r] = t(o) : a.default.array(o) ? n[r] = J.from(o) : n[r] = o;\n    }\n\n    return n;\n  };\n  var Oe = {};\n\n  function Ee(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n      var n = [],\n          r = !0,\n          o = !1,\n          i = void 0;\n\n      try {\n        for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);\n      } catch (t) {\n        o = !0, i = t;\n      } finally {\n        try {\n          r || null == s.return || s.return();\n        } finally {\n          if (o) throw i;\n        }\n      }\n\n      return n;\n    }(t, e) || function (t, e) {\n      if (!t) return;\n      if (\"string\" == typeof t) return Te(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      \"Object\" === n && t.constructor && (n = t.constructor.name);\n      if (\"Map\" === n || \"Set\" === n) return Array.from(t);\n      if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Te(t, e);\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function Te(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  function Me(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  Object.defineProperty(Oe, \"__esModule\", {\n    value: !0\n  }), Oe.getRectOffset = Ie, Oe.default = void 0;\n\n  var je = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.states = [], this.startOffset = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, this.startDelta = null, this.result = null, this.endResult = null, this.edges = void 0, this.interaction = void 0, this.interaction = e, this.result = ke();\n    }\n\n    var e, n, r;\n    return e = t, (n = [{\n      key: \"start\",\n      value: function value(t, e) {\n        var n = t.phase,\n            r = this.interaction,\n            o = function (t) {\n          var e = t.interactable.options[t.prepared.name],\n              n = e.modifiers;\n          return n && n.length ? n : [\"snap\", \"snapSize\", \"snapEdges\", \"restrict\", \"restrictEdges\", \"restrictSize\"].map(function (t) {\n            var n = e[t];\n            return n && n.enabled && {\n              options: n,\n              methods: n._methods\n            };\n          }).filter(function (t) {\n            return !!t;\n          });\n        }(r);\n\n        this.prepareStates(o), this.edges = (0, k.default)({}, r.edges), this.startOffset = Ie(r.rect, e), this.startDelta = {\n          x: 0,\n          y: 0\n        };\n        var i = {\n          phase: n,\n          pageCoords: e,\n          preEnd: !1\n        };\n        return this.result = ke(), this.startAll(i), this.result = this.setAll(i);\n      }\n    }, {\n      key: \"fillArg\",\n      value: function value(t) {\n        var e = this.interaction;\n        t.interaction = e, t.interactable = e.interactable, t.element = e.element, t.rect = t.rect || e.rect, t.edges = this.edges, t.startOffset = this.startOffset;\n      }\n    }, {\n      key: \"startAll\",\n      value: function value(t) {\n        this.fillArg(t);\n\n        for (var e = 0; e < this.states.length; e++) {\n          var n = this.states[e];\n          n.methods.start && (t.state = n, n.methods.start(t));\n        }\n      }\n    }, {\n      key: \"setAll\",\n      value: function value(t) {\n        this.fillArg(t);\n        var e = t.phase,\n            n = t.preEnd,\n            r = t.skipModifiers,\n            o = t.rect;\n        t.coords = (0, k.default)({}, t.pageCoords), t.rect = (0, k.default)({}, o);\n\n        for (var i = r ? this.states.slice(r) : this.states, a = ke(t.coords, t.rect), s = 0; s < i.length; s++) {\n          var l = i[s],\n              u = l.options,\n              c = (0, k.default)({}, t.coords),\n              f = null;\n          l.methods.set && this.shouldDo(u, n, e) && (t.state = l, f = l.methods.set(t), I.addEdges(this.interaction.edges, t.rect, {\n            x: t.coords.x - c.x,\n            y: t.coords.y - c.y\n          })), a.eventProps.push(f);\n        }\n\n        a.delta.x = t.coords.x - t.pageCoords.x, a.delta.y = t.coords.y - t.pageCoords.y, a.rectDelta.left = t.rect.left - o.left, a.rectDelta.right = t.rect.right - o.right, a.rectDelta.top = t.rect.top - o.top, a.rectDelta.bottom = t.rect.bottom - o.bottom;\n        var d = this.result.coords,\n            p = this.result.rect;\n\n        if (d && p) {\n          var v = a.rect.left !== p.left || a.rect.right !== p.right || a.rect.top !== p.top || a.rect.bottom !== p.bottom;\n          a.changed = v || d.x !== a.coords.x || d.y !== a.coords.y;\n        }\n\n        return a;\n      }\n    }, {\n      key: \"applyToInteraction\",\n      value: function value(t) {\n        var e = this.interaction,\n            n = t.phase,\n            r = e.coords.cur,\n            o = e.coords.start,\n            i = this.result,\n            a = this.startDelta,\n            s = i.delta;\n        \"start\" === n && (0, k.default)(this.startDelta, i.delta);\n\n        for (var l = [[o, a], [r, s]], u = 0; u < l.length; u++) {\n          var c = Ee(l[u], 2),\n              f = c[0],\n              d = c[1];\n          f.page.x += d.x, f.page.y += d.y, f.client.x += d.x, f.client.y += d.y;\n        }\n\n        var p = this.result.rectDelta,\n            v = t.rect || e.rect;\n        v.left += p.left, v.right += p.right, v.top += p.top, v.bottom += p.bottom, v.width = v.right - v.left, v.height = v.bottom - v.top;\n      }\n    }, {\n      key: \"setAndApply\",\n      value: function value(t) {\n        var e = this.interaction,\n            n = t.phase,\n            r = t.preEnd,\n            o = t.skipModifiers,\n            i = this.setAll({\n          preEnd: r,\n          phase: n,\n          pageCoords: t.modifiedCoords || e.coords.cur.page\n        });\n        if (this.result = i, !i.changed && (!o || o < this.states.length) && e.interacting()) return !1;\n\n        if (t.modifiedCoords) {\n          var a = e.coords.cur.page,\n              s = {\n            x: t.modifiedCoords.x - a.x,\n            y: t.modifiedCoords.y - a.y\n          };\n          i.coords.x += s.x, i.coords.y += s.y, i.delta.x += s.x, i.delta.y += s.y;\n        }\n\n        this.applyToInteraction(t);\n      }\n    }, {\n      key: \"beforeEnd\",\n      value: function value(t) {\n        var e = t.interaction,\n            n = t.event,\n            r = this.states;\n\n        if (r && r.length) {\n          for (var o = !1, i = 0; i < r.length; i++) {\n            var a = r[i];\n            t.state = a;\n            var s = a.options,\n                l = a.methods,\n                u = l.beforeEnd && l.beforeEnd(t);\n            if (u) return this.endResult = u, !1;\n            o = o || !o && this.shouldDo(s, !0, t.phase, !0);\n          }\n\n          o && e.move({\n            event: n,\n            preEnd: !0\n          });\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function value(t) {\n        var e = t.interaction;\n\n        if (this.states && this.states.length) {\n          var n = (0, k.default)({\n            states: this.states,\n            interactable: e.interactable,\n            element: e.element,\n            rect: null\n          }, t);\n          this.fillArg(n);\n\n          for (var r = 0; r < this.states.length; r++) {\n            var o = this.states[r];\n            n.state = o, o.methods.stop && o.methods.stop(n);\n          }\n\n          this.states = null, this.endResult = null;\n        }\n      }\n    }, {\n      key: \"prepareStates\",\n      value: function value(t) {\n        this.states = [];\n\n        for (var e = 0; e < t.length; e++) {\n          var n = t[e],\n              r = n.options,\n              o = n.methods,\n              i = n.name;\n          this.states.push({\n            options: r,\n            methods: o,\n            index: e,\n            name: i\n          });\n        }\n\n        return this.states;\n      }\n    }, {\n      key: \"restoreInteractionCoords\",\n      value: function value(t) {\n        var e = t.interaction,\n            n = e.coords,\n            r = e.rect,\n            o = e.modification;\n\n        if (o.result) {\n          for (var i = o.startDelta, a = o.result, s = a.delta, l = a.rectDelta, u = [[n.start, i], [n.cur, s]], c = 0; c < u.length; c++) {\n            var f = Ee(u[c], 2),\n                d = f[0],\n                p = f[1];\n            d.page.x -= p.x, d.page.y -= p.y, d.client.x -= p.x, d.client.y -= p.y;\n          }\n\n          r.left -= l.left, r.right -= l.right, r.top -= l.top, r.bottom -= l.bottom;\n        }\n      }\n    }, {\n      key: \"shouldDo\",\n      value: function value(t, e, n, r) {\n        return !(!t || !1 === t.enabled || r && !t.endOnly || t.endOnly && !e || \"start\" === n && !t.setStart);\n      }\n    }, {\n      key: \"copyFrom\",\n      value: function value(t) {\n        this.startOffset = t.startOffset, this.startDelta = t.startDelta, this.edges = t.edges, this.states = t.states.map(function (t) {\n          return (0, Pe.default)(t);\n        }), this.result = ke((0, k.default)({}, t.result.coords), (0, k.default)({}, t.result.rect));\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        for (var t in this) this[t] = null;\n      }\n    }]) && Me(e.prototype, n), r && Me(e, r), t;\n  }();\n\n  function ke(t, e) {\n    return {\n      rect: e,\n      coords: t,\n      delta: {\n        x: 0,\n        y: 0\n      },\n      rectDelta: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      eventProps: [],\n      changed: !0\n    };\n  }\n\n  function Ie(t, e) {\n    return t ? {\n      left: e.x - t.left,\n      top: e.y - t.top,\n      right: t.right - e.x,\n      bottom: t.bottom - e.y\n    } : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n\n  Oe.default = je;\n  var De = {};\n\n  function Ae(t) {\n    var e = t.iEvent,\n        n = t.interaction.modification.result;\n    n && (e.modifiers = n.eventProps);\n  }\n\n  Object.defineProperty(De, \"__esModule\", {\n    value: !0\n  }), De.makeModifier = function (t, e) {\n    var n = t.defaults,\n        r = {\n      start: t.start,\n      set: t.set,\n      beforeEnd: t.beforeEnd,\n      stop: t.stop\n    },\n        o = function o(t) {\n      var o = t || {};\n\n      for (var i in o.enabled = !1 !== o.enabled, n) i in o || (o[i] = n[i]);\n\n      var a = {\n        options: o,\n        methods: r,\n        name: e,\n        enable: function enable() {\n          return o.enabled = !0, a;\n        },\n        disable: function disable() {\n          return o.enabled = !1, a;\n        }\n      };\n      return a;\n    };\n\n    e && \"string\" == typeof e && (o._defaults = n, o._methods = r);\n    return o;\n  }, De.addEventModifiers = Ae, De.default = void 0;\n  var ze = {\n    id: \"modifiers/base\",\n    install: function install(t) {\n      t.defaults.perAction.modifiers = [];\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        var e = t.interaction;\n        e.modification = new Oe.default(e);\n      },\n      \"interactions:before-action-start\": function interactionsBeforeActionStart(t) {\n        var e = t.interaction.modification;\n        e.start(t, t.interaction.coords.start.page), t.interaction.edges = e.edges, e.applyToInteraction(t);\n      },\n      \"interactions:before-action-move\": function interactionsBeforeActionMove(t) {\n        return t.interaction.modification.setAndApply(t);\n      },\n      \"interactions:before-action-end\": function interactionsBeforeActionEnd(t) {\n        return t.interaction.modification.beforeEnd(t);\n      },\n      \"interactions:action-start\": Ae,\n      \"interactions:action-move\": Ae,\n      \"interactions:action-end\": Ae,\n      \"interactions:after-action-start\": function interactionsAfterActionStart(t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      },\n      \"interactions:after-action-move\": function interactionsAfterActionMove(t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      },\n      \"interactions:stop\": function interactionsStop(t) {\n        return t.interaction.modification.stop(t);\n      }\n    },\n    before: [\"actions\"]\n  };\n  De.default = ze;\n  var Ce = {};\n  Object.defineProperty(Ce, \"__esModule\", {\n    value: !0\n  }), Ce.defaults = void 0;\n  Ce.defaults = {\n    base: {\n      preventDefault: \"auto\",\n      deltaSource: \"page\"\n    },\n    perAction: {\n      enabled: !1,\n      origin: {\n        x: 0,\n        y: 0\n      }\n    },\n    actions: {}\n  };\n  var Re = {};\n\n  function Fe(t) {\n    return (Fe = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  function Xe(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function Ye(t, e) {\n    return (Ye = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function We(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var n,\n          r = Ue(t);\n\n      if (e) {\n        var o = Ue(this).constructor;\n        n = Reflect.construct(r, arguments, o);\n      } else n = r.apply(this, arguments);\n\n      return Le(this, n);\n    };\n  }\n\n  function Le(t, e) {\n    return !e || \"object\" !== Fe(e) && \"function\" != typeof e ? Be(t) : e;\n  }\n\n  function Be(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n\n  function Ue(t) {\n    return (Ue = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n\n  Object.defineProperty(Re, \"__esModule\", {\n    value: !0\n  }), Re.InteractEvent = void 0;\n\n  var Ve = function (t) {\n    !function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && Ye(t, e);\n    }(i, t);\n    var e,\n        n,\n        r,\n        o = We(i);\n\n    function i(t, e, n, r, a, s, l) {\n      var u;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, i), (u = o.call(this, t)).target = void 0, u.currentTarget = void 0, u.relatedTarget = null, u.screenX = void 0, u.screenY = void 0, u.button = void 0, u.buttons = void 0, u.ctrlKey = void 0, u.shiftKey = void 0, u.altKey = void 0, u.metaKey = void 0, u.page = void 0, u.client = void 0, u.delta = void 0, u.rect = void 0, u.x0 = void 0, u.y0 = void 0, u.t0 = void 0, u.dt = void 0, u.duration = void 0, u.clientX0 = void 0, u.clientY0 = void 0, u.velocity = void 0, u.speed = void 0, u.swipe = void 0, u.timeStamp = void 0, u.dragEnter = void 0, u.dragLeave = void 0, u.axes = void 0, u.preEnd = void 0, a = a || t.element;\n      var c = t.interactable,\n          f = (c && c.options || Ce.defaults).deltaSource,\n          d = (0, z.default)(c, a, n),\n          p = \"start\" === r,\n          v = \"end\" === r,\n          h = p ? Be(u) : t.prevEvent,\n          g = p ? t.coords.start : v ? {\n        page: h.page,\n        client: h.client,\n        timeStamp: t.coords.cur.timeStamp\n      } : t.coords.cur;\n      return u.page = (0, k.default)({}, g.page), u.client = (0, k.default)({}, g.client), u.rect = (0, k.default)({}, t.rect), u.timeStamp = g.timeStamp, v || (u.page.x -= d.x, u.page.y -= d.y, u.client.x -= d.x, u.client.y -= d.y), u.ctrlKey = e.ctrlKey, u.altKey = e.altKey, u.shiftKey = e.shiftKey, u.metaKey = e.metaKey, u.button = e.button, u.buttons = e.buttons, u.target = a, u.currentTarget = a, u.preEnd = s, u.type = l || n + (r || \"\"), u.interactable = c, u.t0 = p ? t.pointers[t.pointers.length - 1].downTime : h.t0, u.x0 = t.coords.start.page.x - d.x, u.y0 = t.coords.start.page.y - d.y, u.clientX0 = t.coords.start.client.x - d.x, u.clientY0 = t.coords.start.client.y - d.y, u.delta = p || v ? {\n        x: 0,\n        y: 0\n      } : {\n        x: u[f].x - h[f].x,\n        y: u[f].y - h[f].y\n      }, u.dt = t.coords.delta.timeStamp, u.duration = u.timeStamp - u.t0, u.velocity = (0, k.default)({}, t.coords.velocity[f]), u.speed = (0, F.default)(u.velocity.x, u.velocity.y), u.swipe = v || \"inertiastart\" === r ? u.getSwipe() : null, u;\n    }\n\n    return e = i, (n = [{\n      key: \"getSwipe\",\n      value: function value() {\n        var t = this._interaction;\n        if (t.prevEvent.speed < 600 || this.timeStamp - t.prevEvent.timeStamp > 150) return null;\n        var e = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI;\n        e < 0 && (e += 360);\n        var n = 112.5 <= e && e < 247.5,\n            r = 202.5 <= e && e < 337.5;\n        return {\n          up: r,\n          down: !r && 22.5 <= e && e < 157.5,\n          left: n,\n          right: !n && (292.5 <= e || e < 67.5),\n          angle: e,\n          speed: t.prevEvent.speed,\n          velocity: {\n            x: t.prevEvent.velocityX,\n            y: t.prevEvent.velocityY\n          }\n        };\n      }\n    }, {\n      key: \"preventDefault\",\n      value: function value() {}\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function value() {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopPropagation\",\n      value: function value() {\n        this.propagationStopped = !0;\n      }\n    }]) && Xe(e.prototype, n), r && Xe(e, r), i;\n  }(G.BaseEvent);\n\n  Re.InteractEvent = Ve, Object.defineProperties(Ve.prototype, {\n    pageX: {\n      get: function get() {\n        return this.page.x;\n      },\n      set: function set(t) {\n        this.page.x = t;\n      }\n    },\n    pageY: {\n      get: function get() {\n        return this.page.y;\n      },\n      set: function set(t) {\n        this.page.y = t;\n      }\n    },\n    clientX: {\n      get: function get() {\n        return this.client.x;\n      },\n      set: function set(t) {\n        this.client.x = t;\n      }\n    },\n    clientY: {\n      get: function get() {\n        return this.client.y;\n      },\n      set: function set(t) {\n        this.client.y = t;\n      }\n    },\n    dx: {\n      get: function get() {\n        return this.delta.x;\n      },\n      set: function set(t) {\n        this.delta.x = t;\n      }\n    },\n    dy: {\n      get: function get() {\n        return this.delta.y;\n      },\n      set: function set(t) {\n        this.delta.y = t;\n      }\n    },\n    velocityX: {\n      get: function get() {\n        return this.velocity.x;\n      },\n      set: function set(t) {\n        this.velocity.x = t;\n      }\n    },\n    velocityY: {\n      get: function get() {\n        return this.velocity.y;\n      },\n      set: function set(t) {\n        this.velocity.y = t;\n      }\n    }\n  });\n  var qe = {};\n  Object.defineProperty(qe, \"__esModule\", {\n    value: !0\n  }), qe.PointerInfo = void 0;\n\n  qe.PointerInfo = function t(e, n, r, o, i) {\n    !function (t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }(this, t), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = e, this.pointer = n, this.event = r, this.downTime = o, this.downTarget = i;\n  };\n\n  var Ne,\n      $e,\n      Ge = {};\n\n  function He(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function Ke(t, e, n) {\n    return e && He(t.prototype, e), n && He(t, n), t;\n  }\n\n  Object.defineProperty(Ge, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(Ge, \"PointerInfo\", {\n    enumerable: !0,\n    get: function get() {\n      return qe.PointerInfo;\n    }\n  }), Ge.default = Ge.Interaction = Ge._ProxyMethods = Ge._ProxyValues = void 0, Ge._ProxyValues = Ne, function (t) {\n    t.interactable = \"\", t.element = \"\", t.prepared = \"\", t.pointerIsDown = \"\", t.pointerWasMoved = \"\", t._proxy = \"\";\n  }(Ne || (Ge._ProxyValues = Ne = {})), Ge._ProxyMethods = $e, function (t) {\n    t.start = \"\", t.move = \"\", t.end = \"\", t.stop = \"\", t.interacting = \"\";\n  }($e || (Ge._ProxyMethods = $e = {}));\n\n  var Ze = 0,\n      Je = function () {\n    function t(e) {\n      var n = this,\n          r = e.pointerType,\n          o = e.scopeFire;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.interactable = null, this.element = null, this.rect = void 0, this._rects = void 0, this.edges = void 0, this._scopeFire = void 0, this.prepared = {\n        name: null,\n        axis: null,\n        edges: null\n      }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = {\n        pointer: null,\n        event: null,\n        eventTarget: null\n      }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = null, this.simulation = null, this.doMove = (0, Wt.warnOnce)(function (t) {\n        this.move(t);\n      }, \"The interaction.doMove() method has been renamed to interaction.move()\"), this.coords = {\n        start: L.newCoords(),\n        prev: L.newCoords(),\n        cur: L.newCoords(),\n        delta: L.newCoords(),\n        velocity: L.newCoords()\n      }, this._id = Ze++, this._scopeFire = o, this.pointerType = r;\n      var i = this;\n      this._proxy = {};\n\n      var a = function a(t) {\n        Object.defineProperty(n._proxy, t, {\n          get: function get() {\n            return i[t];\n          }\n        });\n      };\n\n      for (var s in Ne) a(s);\n\n      var l = function l(t) {\n        Object.defineProperty(n._proxy, t, {\n          value: function value() {\n            return i[t].apply(i, arguments);\n          }\n        });\n      };\n\n      for (var u in $e) l(u);\n\n      this._scopeFire(\"interactions:new\", {\n        interaction: this\n      });\n    }\n\n    return Ke(t, [{\n      key: \"pointerMoveTolerance\",\n      get: function get() {\n        return 1;\n      }\n    }]), Ke(t, [{\n      key: \"pointerDown\",\n      value: function value(t, e, n) {\n        var r = this.updatePointer(t, e, n, !0),\n            o = this.pointers[r];\n\n        this._scopeFire(\"interactions:down\", {\n          pointer: t,\n          event: e,\n          eventTarget: n,\n          pointerIndex: r,\n          pointerInfo: o,\n          type: \"down\",\n          interaction: this\n        });\n      }\n    }, {\n      key: \"start\",\n      value: function value(t, e, n) {\n        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (\"gesture\" === t.name ? 2 : 1) || !e.options[t.name].enabled) && ((0, Wt.copyAction)(this.prepared, t), this.interactable = e, this.element = n, this.rect = e.getRect(n), this.edges = this.prepared.edges ? (0, k.default)({}, this.prepared.edges) : {\n          left: !0,\n          right: !0,\n          top: !0,\n          bottom: !0\n        }, this._stopped = !1, this._interacting = this._doPhase({\n          interaction: this,\n          event: this.downEvent,\n          phase: \"start\"\n        }) && !this._stopped, this._interacting);\n      }\n    }, {\n      key: \"pointerMove\",\n      value: function value(t, e, n) {\n        this.simulation || this.modification && this.modification.endResult || this.updatePointer(t, e, n, !1);\n        var r,\n            o,\n            i = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;\n        this.pointerIsDown && !this.pointerWasMoved && (r = this.coords.cur.client.x - this.coords.start.client.x, o = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = (0, F.default)(r, o) > this.pointerMoveTolerance);\n        var a = this.getPointerIndex(t),\n            s = {\n          pointer: t,\n          pointerIndex: a,\n          pointerInfo: this.pointers[a],\n          event: e,\n          type: \"move\",\n          eventTarget: n,\n          dx: r,\n          dy: o,\n          duplicate: i,\n          interaction: this\n        };\n        i || L.setCoordVelocity(this.coords.velocity, this.coords.delta), this._scopeFire(\"interactions:move\", s), i || this.simulation || (this.interacting() && (s.type = null, this.move(s)), this.pointerWasMoved && L.copyCoords(this.coords.prev, this.coords.cur));\n      }\n    }, {\n      key: \"move\",\n      value: function value(t) {\n        t && t.event || L.setZeroCoords(this.coords.delta), (t = (0, k.default)({\n          pointer: this._latestPointer.pointer,\n          event: this._latestPointer.event,\n          eventTarget: this._latestPointer.eventTarget,\n          interaction: this\n        }, t || {})).phase = \"move\", this._doPhase(t);\n      }\n    }, {\n      key: \"pointerUp\",\n      value: function value(t, e, n, r) {\n        var o = this.getPointerIndex(t);\n        -1 === o && (o = this.updatePointer(t, e, n, !1));\n        var i = /cancel$/i.test(e.type) ? \"cancel\" : \"up\";\n        this._scopeFire(\"interactions:\".concat(i), {\n          pointer: t,\n          pointerIndex: o,\n          pointerInfo: this.pointers[o],\n          event: e,\n          eventTarget: n,\n          type: i,\n          curEventTarget: r,\n          interaction: this\n        }), this.simulation || this.end(e), this.pointerIsDown = !1, this.removePointer(t, e);\n      }\n    }, {\n      key: \"documentBlur\",\n      value: function value(t) {\n        this.end(t), this._scopeFire(\"interactions:blur\", {\n          event: t,\n          type: \"blur\",\n          interaction: this\n        });\n      }\n    }, {\n      key: \"end\",\n      value: function value(t) {\n        var e;\n        this._ending = !0, t = t || this._latestPointer.event, this.interacting() && (e = this._doPhase({\n          event: t,\n          interaction: this,\n          phase: \"end\"\n        })), this._ending = !1, !0 === e && this.stop();\n      }\n    }, {\n      key: \"currentAction\",\n      value: function value() {\n        return this._interacting ? this.prepared.name : null;\n      }\n    }, {\n      key: \"interacting\",\n      value: function value() {\n        return this._interacting;\n      }\n    }, {\n      key: \"stop\",\n      value: function value() {\n        this._scopeFire(\"interactions:stop\", {\n          interaction: this\n        }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;\n      }\n    }, {\n      key: \"getPointerIndex\",\n      value: function value(t) {\n        var e = L.getPointerId(t);\n        return \"mouse\" === this.pointerType || \"pen\" === this.pointerType ? this.pointers.length - 1 : J.findIndex(this.pointers, function (t) {\n          return t.id === e;\n        });\n      }\n    }, {\n      key: \"getPointerInfo\",\n      value: function value(t) {\n        return this.pointers[this.getPointerIndex(t)];\n      }\n    }, {\n      key: \"updatePointer\",\n      value: function value(t, e, n, r) {\n        var o = L.getPointerId(t),\n            i = this.getPointerIndex(t),\n            a = this.pointers[i];\n        return r = !1 !== r && (r || /(down|start)$/i.test(e.type)), a ? a.pointer = t : (a = new qe.PointerInfo(o, t, e, null, null), i = this.pointers.length, this.pointers.push(a)), L.setCoords(this.coords.cur, this.pointers.map(function (t) {\n          return t.pointer;\n        }), this._now()), L.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur), r && (this.pointerIsDown = !0, a.downTime = this.coords.cur.timeStamp, a.downTarget = n, L.pointerExtend(this.downPointer, t), this.interacting() || (L.copyCoords(this.coords.start, this.coords.cur), L.copyCoords(this.coords.prev, this.coords.cur), this.downEvent = e, this.pointerWasMoved = !1)), this._updateLatestPointer(t, e, n), this._scopeFire(\"interactions:update-pointer\", {\n          pointer: t,\n          event: e,\n          eventTarget: n,\n          down: r,\n          pointerInfo: a,\n          pointerIndex: i,\n          interaction: this\n        }), i;\n      }\n    }, {\n      key: \"removePointer\",\n      value: function value(t, e) {\n        var n = this.getPointerIndex(t);\n\n        if (-1 !== n) {\n          var r = this.pointers[n];\n          this._scopeFire(\"interactions:remove-pointer\", {\n            pointer: t,\n            event: e,\n            eventTarget: null,\n            pointerIndex: n,\n            pointerInfo: r,\n            interaction: this\n          }), this.pointers.splice(n, 1);\n        }\n      }\n    }, {\n      key: \"_updateLatestPointer\",\n      value: function value(t, e, n) {\n        this._latestPointer.pointer = t, this._latestPointer.event = e, this._latestPointer.eventTarget = n;\n      }\n    }, {\n      key: \"destroy\",\n      value: function value() {\n        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;\n      }\n    }, {\n      key: \"_createPreparedEvent\",\n      value: function value(t, e, n, r) {\n        return new Re.InteractEvent(this, t, this.prepared.name, e, this.element, n, r);\n      }\n    }, {\n      key: \"_fireEvent\",\n      value: function value(t) {\n        this.interactable.fire(t), (!this.prevEvent || t.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = t);\n      }\n    }, {\n      key: \"_doPhase\",\n      value: function value(t) {\n        var e = t.event,\n            n = t.phase,\n            r = t.preEnd,\n            o = t.type,\n            i = this.rect;\n        if (i && \"move\" === n && (I.addEdges(this.edges, i, this.coords.delta[this.interactable.options.deltaSource]), i.width = i.right - i.left, i.height = i.bottom - i.top), !1 === this._scopeFire(\"interactions:before-action-\".concat(n), t)) return !1;\n\n        var a = t.iEvent = this._createPreparedEvent(e, n, r, o);\n\n        return this._scopeFire(\"interactions:action-\".concat(n), t), \"start\" === n && (this.prevEvent = a), this._fireEvent(a), this._scopeFire(\"interactions:after-action-\".concat(n), t), !0;\n      }\n    }, {\n      key: \"_now\",\n      value: function value() {\n        return Date.now();\n      }\n    }]), t;\n  }();\n\n  Ge.Interaction = Je;\n  var Qe = Je;\n  Ge.default = Qe;\n  var tn = {};\n\n  function en(t) {\n    t.pointerIsDown && (an(t.coords.cur, t.offset.total), t.offset.pending.x = 0, t.offset.pending.y = 0);\n  }\n\n  function nn(t) {\n    rn(t.interaction);\n  }\n\n  function rn(t) {\n    if (!function (t) {\n      return !(!t.offset.pending.x && !t.offset.pending.y);\n    }(t)) return !1;\n    var e = t.offset.pending;\n    return an(t.coords.cur, e), an(t.coords.delta, e), I.addEdges(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;\n  }\n\n  function on(t) {\n    var e = t.x,\n        n = t.y;\n    this.offset.pending.x += e, this.offset.pending.y += n, this.offset.total.x += e, this.offset.total.y += n;\n  }\n\n  function an(t, e) {\n    var n = t.page,\n        r = t.client,\n        o = e.x,\n        i = e.y;\n    n.x += o, n.y += i, r.x += o, r.y += i;\n  }\n\n  Object.defineProperty(tn, \"__esModule\", {\n    value: !0\n  }), tn.addTotal = en, tn.applyPending = rn, tn.default = void 0, Ge._ProxyMethods.offsetBy = \"\";\n  var sn = {\n    id: \"offset\",\n    before: [\"modifiers\"],\n    install: function install(t) {\n      t.Interaction.prototype.offsetBy = on;\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        t.interaction.offset = {\n          total: {\n            x: 0,\n            y: 0\n          },\n          pending: {\n            x: 0,\n            y: 0\n          }\n        };\n      },\n      \"interactions:update-pointer\": function interactionsUpdatePointer(t) {\n        return en(t.interaction);\n      },\n      \"interactions:before-action-start\": nn,\n      \"interactions:before-action-move\": nn,\n      \"interactions:before-action-end\": function interactionsBeforeActionEnd(t) {\n        var e = t.interaction;\n        if (rn(e)) return e.move({\n          offset: !0\n        }), e.end(), !1;\n      },\n      \"interactions:stop\": function interactionsStop(t) {\n        var e = t.interaction;\n        e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;\n      }\n    }\n  };\n  tn.default = sn;\n  var ln = {};\n\n  function un(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  Object.defineProperty(ln, \"__esModule\", {\n    value: !0\n  }), ln.default = ln.InertiaState = void 0;\n\n  var cn = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = null, this.modifierCount = 0, this.modifierArg = null, this.startCoords = null, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = null, this.modifiedOffset = null, this.currentOffset = null, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = null, this.interaction = void 0, this.interaction = e;\n    }\n\n    var e, n, r;\n    return e = t, (n = [{\n      key: \"start\",\n      value: function value(t) {\n        var e = this.interaction,\n            n = fn(e);\n        if (!n || !n.enabled) return !1;\n        var r = e.coords.velocity.client,\n            o = (0, F.default)(r.x, r.y),\n            i = this.modification || (this.modification = new Oe.default(e));\n        if (i.copyFrom(e.modification), this.t0 = e._now(), this.allowResume = n.allowResume, this.v0 = o, this.currentOffset = {\n          x: 0,\n          y: 0\n        }, this.startCoords = e.coords.cur.page, this.modifierArg = {\n          interaction: e,\n          interactable: e.interactable,\n          element: e.element,\n          rect: e.rect,\n          edges: e.edges,\n          pageCoords: this.startCoords,\n          preEnd: !0,\n          phase: \"inertiastart\"\n        }, this.t0 - e.coords.cur.timeStamp < 50 && o > n.minSpeed && o > n.endSpeed) this.startInertia();else {\n          if (i.result = i.setAll(this.modifierArg), !i.result.changed) return !1;\n          this.startSmoothEnd();\n        }\n        return e.modification.result.rect = null, e.offsetBy(this.targetOffset), e._doPhase({\n          interaction: e,\n          event: t,\n          phase: \"inertiastart\"\n        }), e.offsetBy({\n          x: -this.targetOffset.x,\n          y: -this.targetOffset.y\n        }), e.modification.result.rect = null, this.active = !0, e.simulation = this, !0;\n      }\n    }, {\n      key: \"startInertia\",\n      value: function value() {\n        var t = this,\n            e = this.interaction.coords.velocity.client,\n            n = fn(this.interaction),\n            r = n.resistance,\n            o = -Math.log(n.endSpeed / this.v0) / r;\n        this.targetOffset = {\n          x: (e.x - o) / r,\n          y: (e.y - o) / r\n        }, this.te = o, this.lambda_v0 = r / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;\n        var i = this.modification,\n            a = this.modifierArg;\n        a.pageCoords = {\n          x: this.startCoords.x + this.targetOffset.x,\n          y: this.startCoords.y + this.targetOffset.y\n        }, i.result = i.setAll(a), i.result.changed && (this.isModified = !0, this.modifiedOffset = {\n          x: this.targetOffset.x + i.result.delta.x,\n          y: this.targetOffset.y + i.result.delta.y\n        }), this.timeout = kt.default.request(function () {\n          return t.inertiaTick();\n        });\n      }\n    }, {\n      key: \"startSmoothEnd\",\n      value: function value() {\n        var t = this;\n        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = {\n          x: this.modification.result.delta.x,\n          y: this.modification.result.delta.y\n        }, this.timeout = kt.default.request(function () {\n          return t.smoothEndTick();\n        });\n      }\n    }, {\n      key: \"inertiaTick\",\n      value: function value() {\n        var t,\n            e,\n            n,\n            r,\n            o,\n            i,\n            a,\n            s = this,\n            l = this.interaction,\n            u = fn(l).resistance,\n            c = (l._now() - this.t0) / 1e3;\n\n        if (c < this.te) {\n          var f,\n              d = 1 - (Math.exp(-u * c) - this.lambda_v0) / this.one_ve_v0;\n          this.isModified ? (t = 0, e = 0, n = this.targetOffset.x, r = this.targetOffset.y, o = this.modifiedOffset.x, i = this.modifiedOffset.y, f = {\n            x: dn(a = d, t, n, o),\n            y: dn(a, e, r, i)\n          }) : f = {\n            x: this.targetOffset.x * d,\n            y: this.targetOffset.y * d\n          };\n          var p = {\n            x: f.x - this.currentOffset.x,\n            y: f.y - this.currentOffset.y\n          };\n          this.currentOffset.x += p.x, this.currentOffset.y += p.y, l.offsetBy(p), l.move(), this.timeout = kt.default.request(function () {\n            return s.inertiaTick();\n          });\n        } else l.offsetBy({\n          x: this.modifiedOffset.x - this.currentOffset.x,\n          y: this.modifiedOffset.y - this.currentOffset.y\n        }), this.end();\n      }\n    }, {\n      key: \"smoothEndTick\",\n      value: function value() {\n        var t = this,\n            e = this.interaction,\n            n = e._now() - this.t0,\n            r = fn(e).smoothEndDuration;\n\n        if (n < r) {\n          var o = {\n            x: pn(n, 0, this.targetOffset.x, r),\n            y: pn(n, 0, this.targetOffset.y, r)\n          },\n              i = {\n            x: o.x - this.currentOffset.x,\n            y: o.y - this.currentOffset.y\n          };\n          this.currentOffset.x += i.x, this.currentOffset.y += i.y, e.offsetBy(i), e.move({\n            skipModifiers: this.modifierCount\n          }), this.timeout = kt.default.request(function () {\n            return t.smoothEndTick();\n          });\n        } else e.offsetBy({\n          x: this.targetOffset.x - this.currentOffset.x,\n          y: this.targetOffset.y - this.currentOffset.y\n        }), this.end();\n      }\n    }, {\n      key: \"resume\",\n      value: function value(t) {\n        var e = t.pointer,\n            n = t.event,\n            r = t.eventTarget,\n            o = this.interaction;\n        o.offsetBy({\n          x: -this.currentOffset.x,\n          y: -this.currentOffset.y\n        }), o.updatePointer(e, n, r, !0), o._doPhase({\n          interaction: o,\n          event: n,\n          phase: \"resume\"\n        }), (0, L.copyCoords)(o.coords.prev, o.coords.cur), this.stop();\n      }\n    }, {\n      key: \"end\",\n      value: function value() {\n        this.interaction.move(), this.interaction.end(), this.stop();\n      }\n    }, {\n      key: \"stop\",\n      value: function value() {\n        this.active = this.smoothEnd = !1, this.interaction.simulation = null, kt.default.cancel(this.timeout);\n      }\n    }]) && un(e.prototype, n), r && un(e, r), t;\n  }();\n\n  function fn(t) {\n    var e = t.interactable,\n        n = t.prepared;\n    return e && e.options && n.name && e.options[n.name].inertia;\n  }\n\n  function dn(t, e, n, r) {\n    var o = 1 - t;\n    return o * o * e + 2 * o * t * n + t * t * r;\n  }\n\n  function pn(t, e, n, r) {\n    return -n * (t /= r) * (t - 2) + e;\n  }\n\n  ln.InertiaState = cn;\n  var vn = {\n    id: \"inertia\",\n    before: [\"modifiers\"],\n    install: function install(t) {\n      var e = t.defaults;\n      t.usePlugin(tn.default), t.usePlugin(De.default), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = {\n        enabled: !1,\n        resistance: 10,\n        minSpeed: 100,\n        endSpeed: 10,\n        allowResume: !0,\n        smoothEndDuration: 300\n      };\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        var e = t.interaction;\n        e.inertia = new cn(e);\n      },\n      \"interactions:before-action-end\": function interactionsBeforeActionEnd(t) {\n        var e = t.interaction,\n            n = t.event;\n        return (!e._interacting || e.simulation || !e.inertia.start(n)) && null;\n      },\n      \"interactions:down\": function interactionsDown(t) {\n        var e = t.interaction,\n            n = t.eventTarget,\n            r = e.inertia;\n        if (r.active) for (var o = n; a.default.element(o);) {\n          if (o === e.element) {\n            r.resume(t);\n            break;\n          }\n\n          o = S.parentNode(o);\n        }\n      },\n      \"interactions:stop\": function interactionsStop(t) {\n        var e = t.interaction.inertia;\n        e.active && e.stop();\n      },\n      \"interactions:before-action-resume\": function interactionsBeforeActionResume(t) {\n        var e = t.interaction.modification;\n        e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);\n      },\n      \"interactions:before-action-inertiastart\": function interactionsBeforeActionInertiastart(t) {\n        return t.interaction.modification.setAndApply(t);\n      },\n      \"interactions:action-resume\": De.addEventModifiers,\n      \"interactions:action-inertiastart\": De.addEventModifiers,\n      \"interactions:after-action-inertiastart\": function interactionsAfterActionInertiastart(t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      },\n      \"interactions:after-action-resume\": function interactionsAfterActionResume(t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      }\n    }\n  };\n  ln.default = vn;\n  var hn = {};\n\n  function gn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function yn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      if (t.immediatePropagationStopped) break;\n      r(t);\n    }\n  }\n\n  Object.defineProperty(hn, \"__esModule\", {\n    value: !0\n  }), hn.Eventable = void 0;\n\n  var mn = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = (0, k.default)({}, e || {});\n    }\n\n    var e, n, r;\n    return e = t, (n = [{\n      key: \"fire\",\n      value: function value(t) {\n        var e,\n            n = this.global;\n        (e = this.types[t.type]) && yn(t, e), !t.propagationStopped && n && (e = n[t.type]) && yn(t, e);\n      }\n    }, {\n      key: \"on\",\n      value: function value(t, e) {\n        var n = (0, C.default)(t, e);\n\n        for (t in n) this.types[t] = J.merge(this.types[t] || [], n[t]);\n      }\n    }, {\n      key: \"off\",\n      value: function value(t, e) {\n        var n = (0, C.default)(t, e);\n\n        for (t in n) {\n          var r = this.types[t];\n          if (r && r.length) for (var o = 0; o < n[t].length; o++) {\n            var i = n[t][o],\n                a = r.indexOf(i);\n            -1 !== a && r.splice(a, 1);\n          }\n        }\n      }\n    }, {\n      key: \"getRect\",\n      value: function value(t) {\n        return null;\n      }\n    }]) && gn(e.prototype, n), r && gn(e, r), t;\n  }();\n\n  hn.Eventable = mn;\n  var bn = {};\n  Object.defineProperty(bn, \"__esModule\", {\n    value: !0\n  }), bn.default = function (t, e) {\n    if (e.phaselessTypes[t]) return !0;\n\n    for (var n in e.map) if (0 === t.indexOf(n) && t.substr(n.length) in e.phases) return !0;\n\n    return !1;\n  };\n  var xn = {};\n\n  function wn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function _n(t, e, n) {\n    return e && wn(t.prototype, e), n && wn(t, n), t;\n  }\n\n  Object.defineProperty(xn, \"__esModule\", {\n    value: !0\n  }), xn.Interactable = void 0;\n\n  var Sn = function () {\n    function t(n, r, o, i) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.options = void 0, this._actions = void 0, this.target = void 0, this.events = new hn.Eventable(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._rectChecker = void 0, this._actions = r.actions, this.target = n, this._context = r.context || o, this._win = (0, e.getWindow)((0, S.trySelector)(n) ? this._context : n), this._doc = this._win.document, this._scopeEvents = i, this.set(r);\n    }\n\n    return _n(t, [{\n      key: \"_defaults\",\n      get: function get() {\n        return {\n          base: {},\n          perAction: {},\n          actions: {}\n        };\n      }\n    }]), _n(t, [{\n      key: \"setOnEvents\",\n      value: function value(t, e) {\n        return a.default.func(e.onstart) && this.on(\"\".concat(t, \"start\"), e.onstart), a.default.func(e.onmove) && this.on(\"\".concat(t, \"move\"), e.onmove), a.default.func(e.onend) && this.on(\"\".concat(t, \"end\"), e.onend), a.default.func(e.oninertiastart) && this.on(\"\".concat(t, \"inertiastart\"), e.oninertiastart), this;\n      }\n    }, {\n      key: \"updatePerActionListeners\",\n      value: function value(t, e, n) {\n        (a.default.array(e) || a.default.object(e)) && this.off(t, e), (a.default.array(n) || a.default.object(n)) && this.on(t, n);\n      }\n    }, {\n      key: \"setPerAction\",\n      value: function value(t, e) {\n        var n = this._defaults;\n\n        for (var r in e) {\n          var o = r,\n              i = this.options[t],\n              s = e[o];\n          \"listeners\" === o && this.updatePerActionListeners(t, i.listeners, s), a.default.array(s) ? i[o] = J.from(s) : a.default.plainObject(s) ? (i[o] = (0, k.default)(i[o] || {}, (0, Pe.default)(s)), a.default.object(n.perAction[o]) && \"enabled\" in n.perAction[o] && (i[o].enabled = !1 !== s.enabled)) : a.default.bool(s) && a.default.object(n.perAction[o]) ? i[o].enabled = s : i[o] = s;\n        }\n      }\n    }, {\n      key: \"getRect\",\n      value: function value(t) {\n        return t = t || (a.default.element(this.target) ? this.target : null), a.default.string(this.target) && (t = t || this._context.querySelector(this.target)), (0, S.getElementRect)(t);\n      }\n    }, {\n      key: \"rectChecker\",\n      value: function value(t) {\n        var e = this;\n        return a.default.func(t) ? (this._rectChecker = t, this.getRect = function (t) {\n          var n = (0, k.default)({}, e._rectChecker(t));\n          return \"width\" in n || (n.width = n.right - n.left, n.height = n.bottom - n.top), n;\n        }, this) : null === t ? (delete this.getRect, delete this._rectChecker, this) : this.getRect;\n      }\n    }, {\n      key: \"_backCompatOption\",\n      value: function value(t, e) {\n        if ((0, S.trySelector)(e) || a.default.object(e)) {\n          for (var n in this.options[t] = e, this._actions.map) this.options[n][t] = e;\n\n          return this;\n        }\n\n        return this.options[t];\n      }\n    }, {\n      key: \"origin\",\n      value: function value(t) {\n        return this._backCompatOption(\"origin\", t);\n      }\n    }, {\n      key: \"deltaSource\",\n      value: function value(t) {\n        return \"page\" === t || \"client\" === t ? (this.options.deltaSource = t, this) : this.options.deltaSource;\n      }\n    }, {\n      key: \"context\",\n      value: function value() {\n        return this._context;\n      }\n    }, {\n      key: \"inContext\",\n      value: function value(t) {\n        return this._context === t.ownerDocument || (0, S.nodeContains)(this._context, t);\n      }\n    }, {\n      key: \"testIgnoreAllow\",\n      value: function value(t, e, n) {\n        return !this.testIgnore(t.ignoreFrom, e, n) && this.testAllow(t.allowFrom, e, n);\n      }\n    }, {\n      key: \"testAllow\",\n      value: function value(t, e, n) {\n        return !t || !!a.default.element(n) && (a.default.string(t) ? (0, S.matchesUpTo)(n, t, e) : !!a.default.element(t) && (0, S.nodeContains)(t, n));\n      }\n    }, {\n      key: \"testIgnore\",\n      value: function value(t, e, n) {\n        return !(!t || !a.default.element(n)) && (a.default.string(t) ? (0, S.matchesUpTo)(n, t, e) : !!a.default.element(t) && (0, S.nodeContains)(t, n));\n      }\n    }, {\n      key: \"fire\",\n      value: function value(t) {\n        return this.events.fire(t), this;\n      }\n    }, {\n      key: \"_onOff\",\n      value: function value(t, e, n, r) {\n        a.default.object(e) && !a.default.array(e) && (r = n, n = null);\n        var o = \"on\" === t ? \"add\" : \"remove\",\n            i = (0, C.default)(e, n);\n\n        for (var s in i) {\n          \"wheel\" === s && (s = x.default.wheelEvent);\n\n          for (var l = 0; l < i[s].length; l++) {\n            var u = i[s][l];\n            (0, bn.default)(s, this._actions) ? this.events[t](s, u) : a.default.string(this.target) ? this._scopeEvents[\"\".concat(o, \"Delegate\")](this.target, this._context, s, u, r) : this._scopeEvents[o](this.target, s, u, r);\n          }\n        }\n\n        return this;\n      }\n    }, {\n      key: \"on\",\n      value: function value(t, e, n) {\n        return this._onOff(\"on\", t, e, n);\n      }\n    }, {\n      key: \"off\",\n      value: function value(t, e, n) {\n        return this._onOff(\"off\", t, e, n);\n      }\n    }, {\n      key: \"set\",\n      value: function value(t) {\n        var e = this._defaults;\n\n        for (var n in a.default.object(t) || (t = {}), this.options = (0, Pe.default)(e.base), this._actions.methodDict) {\n          var r = n,\n              o = this._actions.methodDict[r];\n          this.options[r] = {}, this.setPerAction(r, (0, k.default)((0, k.default)({}, e.perAction), e.actions[r])), this[o](t[r]);\n        }\n\n        for (var i in t) a.default.func(this[i]) && this[i](t[i]);\n\n        return this;\n      }\n    }, {\n      key: \"unset\",\n      value: function value() {\n        if (a.default.string(this.target)) for (var t in this._scopeEvents.delegatedEvents) for (var e = this._scopeEvents.delegatedEvents[t], n = e.length - 1; n >= 0; n--) {\n          var r = e[n],\n              o = r.selector,\n              i = r.context,\n              s = r.listeners;\n          o === this.target && i === this._context && e.splice(n, 1);\n\n          for (var l = s.length - 1; l >= 0; l--) this._scopeEvents.removeDelegate(this.target, this._context, t, s[l][0], s[l][1]);\n        } else this._scopeEvents.remove(this.target, \"all\");\n      }\n    }]), t;\n  }();\n\n  xn.Interactable = Sn;\n  var Pn = {};\n\n  function On(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  Object.defineProperty(Pn, \"__esModule\", {\n    value: !0\n  }), Pn.InteractableSet = void 0;\n\n  var En = function () {\n    function t(e) {\n      var n = this;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = e, e.addListeners({\n        \"interactable:unset\": function interactableUnset(t) {\n          var e = t.interactable,\n              r = e.target,\n              o = e._context,\n              i = a.default.string(r) ? n.selectorMap[r] : r[n.scope.id],\n              s = i.findIndex(function (t) {\n            return t.context === o;\n          });\n          i[s] && (i[s].context = null, i[s].interactable = null), i.splice(s, 1);\n        }\n      });\n    }\n\n    var e, n, r;\n    return e = t, (n = [{\n      key: \"new\",\n      value: function value(t, e) {\n        e = (0, k.default)(e || {}, {\n          actions: this.scope.actions\n        });\n        var n = new this.scope.Interactable(t, e, this.scope.document, this.scope.events),\n            r = {\n          context: n._context,\n          interactable: n\n        };\n        return this.scope.addDocument(n._doc), this.list.push(n), a.default.string(t) ? (this.selectorMap[t] || (this.selectorMap[t] = []), this.selectorMap[t].push(r)) : (n.target[this.scope.id] || Object.defineProperty(t, this.scope.id, {\n          value: [],\n          configurable: !0\n        }), t[this.scope.id].push(r)), this.scope.fire(\"interactable:new\", {\n          target: t,\n          options: e,\n          interactable: n,\n          win: this.scope._win\n        }), n;\n      }\n    }, {\n      key: \"get\",\n      value: function value(t, e) {\n        var n = e && e.context || this.scope.document,\n            r = a.default.string(t),\n            o = r ? this.selectorMap[t] : t[this.scope.id];\n        if (!o) return null;\n        var i = J.find(o, function (e) {\n          return e.context === n && (r || e.interactable.inContext(t));\n        });\n        return i && i.interactable;\n      }\n    }, {\n      key: \"forEachMatch\",\n      value: function value(t, e) {\n        for (var n = 0; n < this.list.length; n++) {\n          var r = this.list[n],\n              o = void 0;\n          if ((a.default.string(r.target) ? a.default.element(t) && S.matchesSelector(t, r.target) : t === r.target) && r.inContext(t) && (o = e(r)), void 0 !== o) return o;\n        }\n      }\n    }]) && On(e.prototype, n), r && On(e, r), t;\n  }();\n\n  Pn.InteractableSet = En;\n  var Tn = {};\n\n  function Mn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function jn(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n      var n = [],\n          r = !0,\n          o = !1,\n          i = void 0;\n\n      try {\n        for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);\n      } catch (t) {\n        o = !0, i = t;\n      } finally {\n        try {\n          r || null == s.return || s.return();\n        } finally {\n          if (o) throw i;\n        }\n      }\n\n      return n;\n    }(t, e) || function (t, e) {\n      if (!t) return;\n      if (\"string\" == typeof t) return kn(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      \"Object\" === n && t.constructor && (n = t.constructor.name);\n      if (\"Map\" === n || \"Set\" === n) return Array.from(t);\n      if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return kn(t, e);\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function kn(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  Object.defineProperty(Tn, \"__esModule\", {\n    value: !0\n  }), Tn.default = Tn.FakeEvent = void 0;\n\n  var In = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), this.currentTarget = void 0, this.originalEvent = void 0, this.originalEvent = e, (0, X.default)(this, e);\n    }\n\n    var e, n, r;\n    return e = t, (n = [{\n      key: \"preventOriginalDefault\",\n      value: function value() {\n        this.originalEvent.preventDefault();\n      }\n    }, {\n      key: \"stopPropagation\",\n      value: function value() {\n        this.originalEvent.stopPropagation();\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function value() {\n        this.originalEvent.stopImmediatePropagation();\n      }\n    }]) && Mn(e.prototype, n), r && Mn(e, r), t;\n  }();\n\n  function Dn(t) {\n    if (!a.default.object(t)) return {\n      capture: !!t,\n      passive: !1\n    };\n    var e = (0, k.default)({}, t);\n    return e.capture = !!t.capture, e.passive = !!t.passive, e;\n  }\n\n  Tn.FakeEvent = In;\n  var An = {\n    id: \"events\",\n    install: function install(t) {\n      var e = [],\n          n = {},\n          r = [],\n          o = {\n        add: i,\n        remove: s,\n        addDelegate: function addDelegate(t, e, o, a, s) {\n          var c = Dn(s);\n\n          if (!n[o]) {\n            n[o] = [];\n\n            for (var f = 0; f < r.length; f++) {\n              var d = r[f];\n              i(d, o, l), i(d, o, u, !0);\n            }\n          }\n\n          var p = n[o],\n              v = J.find(p, function (n) {\n            return n.selector === t && n.context === e;\n          });\n          v || (v = {\n            selector: t,\n            context: e,\n            listeners: []\n          }, p.push(v));\n          v.listeners.push([a, c]);\n        },\n        removeDelegate: function removeDelegate(t, e, r, o, i) {\n          var a,\n              c = Dn(i),\n              f = n[r],\n              d = !1;\n          if (!f) return;\n\n          for (a = f.length - 1; a >= 0; a--) {\n            var p = f[a];\n\n            if (p.selector === t && p.context === e) {\n              for (var v = p.listeners, h = v.length - 1; h >= 0; h--) {\n                var g = jn(v[h], 2),\n                    y = g[0],\n                    m = g[1],\n                    b = m.capture,\n                    x = m.passive;\n\n                if (y === o && b === c.capture && x === c.passive) {\n                  v.splice(h, 1), v.length || (f.splice(a, 1), s(e, r, l), s(e, r, u, !0)), d = !0;\n                  break;\n                }\n              }\n\n              if (d) break;\n            }\n          }\n        },\n        delegateListener: l,\n        delegateUseCapture: u,\n        delegatedEvents: n,\n        documents: r,\n        targets: e,\n        supportsOptions: !1,\n        supportsPassive: !1\n      };\n\n      function i(t, n, r, i) {\n        var a = Dn(i),\n            s = J.find(e, function (e) {\n          return e.eventTarget === t;\n        });\n        s || (s = {\n          eventTarget: t,\n          events: {}\n        }, e.push(s)), s.events[n] || (s.events[n] = []), t.addEventListener && !J.contains(s.events[n], r) && (t.addEventListener(n, r, o.supportsOptions ? a : a.capture), s.events[n].push(r));\n      }\n\n      function s(t, n, r, i) {\n        var a = Dn(i),\n            l = J.findIndex(e, function (e) {\n          return e.eventTarget === t;\n        }),\n            u = e[l];\n        if (u && u.events) if (\"all\" !== n) {\n          var c = !1,\n              f = u.events[n];\n\n          if (f) {\n            if (\"all\" === r) {\n              for (var d = f.length - 1; d >= 0; d--) s(t, n, f[d], a);\n\n              return;\n            }\n\n            for (var p = 0; p < f.length; p++) if (f[p] === r) {\n              t.removeEventListener(n, r, o.supportsOptions ? a : a.capture), f.splice(p, 1), 0 === f.length && (delete u.events[n], c = !0);\n              break;\n            }\n          }\n\n          c && !Object.keys(u.events).length && e.splice(l, 1);\n        } else for (n in u.events) u.events.hasOwnProperty(n) && s(t, n, \"all\");\n      }\n\n      function l(t, e) {\n        for (var r = Dn(e), o = new In(t), i = n[t.type], s = jn(L.getEventTargets(t), 1)[0], l = s; a.default.element(l);) {\n          for (var u = 0; u < i.length; u++) {\n            var c = i[u],\n                f = c.selector,\n                d = c.context;\n\n            if (S.matchesSelector(l, f) && S.nodeContains(d, s) && S.nodeContains(d, l)) {\n              var p = c.listeners;\n              o.currentTarget = l;\n\n              for (var v = 0; v < p.length; v++) {\n                var h = jn(p[v], 2),\n                    g = h[0],\n                    y = h[1],\n                    m = y.capture,\n                    b = y.passive;\n                m === r.capture && b === r.passive && g(o);\n              }\n            }\n          }\n\n          l = S.parentNode(l);\n        }\n      }\n\n      function u(t) {\n        return l(t, !0);\n      }\n\n      return t.document.createElement(\"div\").addEventListener(\"test\", null, {\n        get capture() {\n          return o.supportsOptions = !0;\n        },\n\n        get passive() {\n          return o.supportsPassive = !0;\n        }\n\n      }), t.events = o, o;\n    }\n  };\n  Tn.default = An;\n  var zn = {};\n  Object.defineProperty(zn, \"__esModule\", {\n    value: !0\n  }), zn.createInteractStatic = function (t) {\n    var e = function e(n, r) {\n      var o = t.interactables.get(n, r);\n      return o || ((o = t.interactables.new(n, r)).events.global = e.globalEvents), o;\n    };\n\n    return e.getPointerAverage = L.pointerAverage, e.getTouchBBox = L.touchBBox, e.getTouchDistance = L.touchDistance, e.getTouchAngle = L.touchAngle, e.getElementRect = S.getElementRect, e.getElementClientRect = S.getElementClientRect, e.matchesSelector = S.matchesSelector, e.closest = S.closest, e.globalEvents = {}, e.version = void 0, e.scope = t, e.use = function (t, e) {\n      return this.scope.usePlugin(t, e), this;\n    }, e.isSet = function (t, e) {\n      return !!this.scope.interactables.get(t, e && e.context);\n    }, e.on = function (t, e, n) {\n      if (a.default.string(t) && -1 !== t.search(\" \") && (t = t.trim().split(/ +/)), a.default.array(t)) {\n        for (var r = 0; r < t.length; r++) {\n          var o = t[r];\n          this.on(o, e, n);\n        }\n\n        return this;\n      }\n\n      if (a.default.object(t)) {\n        for (var i in t) this.on(i, t[i], e);\n\n        return this;\n      }\n\n      return (0, bn.default)(t, this.scope.actions) ? this.globalEvents[t] ? this.globalEvents[t].push(e) : this.globalEvents[t] = [e] : this.scope.events.add(this.scope.document, t, e, {\n        options: n\n      }), this;\n    }, e.off = function (t, e, n) {\n      if (a.default.string(t) && -1 !== t.search(\" \") && (t = t.trim().split(/ +/)), a.default.array(t)) {\n        for (var r = 0; r < t.length; r++) {\n          var o = t[r];\n          this.off(o, e, n);\n        }\n\n        return this;\n      }\n\n      if (a.default.object(t)) {\n        for (var i in t) this.off(i, t[i], e);\n\n        return this;\n      }\n\n      var s;\n      (0, bn.default)(t, this.scope.actions) ? t in this.globalEvents && -1 !== (s = this.globalEvents[t].indexOf(e)) && this.globalEvents[t].splice(s, 1) : this.scope.events.remove(this.scope.document, t, e, n);\n      return this;\n    }, e.debug = function () {\n      return this.scope;\n    }, e.supportsTouch = function () {\n      return x.default.supportsTouch;\n    }, e.supportsPointerEvent = function () {\n      return x.default.supportsPointerEvent;\n    }, e.stop = function () {\n      for (var t = 0; t < this.scope.interactions.list.length; t++) {\n        this.scope.interactions.list[t].stop();\n      }\n\n      return this;\n    }, e.pointerMoveTolerance = function (t) {\n      return a.default.number(t) ? (this.scope.interactions.pointerMoveTolerance = t, this) : this.scope.interactions.pointerMoveTolerance;\n    }, e.addDocument = function (t, e) {\n      this.scope.addDocument(t, e);\n    }, e.removeDocument = function (t) {\n      this.scope.removeDocument(t);\n    }, e;\n  };\n  var Cn = {};\n  Object.defineProperty(Cn, \"__esModule\", {\n    value: !0\n  }), Cn.default = void 0;\n  var Rn = {\n    methodOrder: [\"simulationResume\", \"mouseOrPen\", \"hasPointer\", \"idle\"],\n    search: function search(t) {\n      for (var e = 0; e < Rn.methodOrder.length; e++) {\n        var n;\n        n = Rn.methodOrder[e];\n        var r = Rn[n](t);\n        if (r) return r;\n      }\n\n      return null;\n    },\n    simulationResume: function simulationResume(t) {\n      var e = t.pointerType,\n          n = t.eventType,\n          r = t.eventTarget,\n          o = t.scope;\n      if (!/down|start/i.test(n)) return null;\n\n      for (var i = 0; i < o.interactions.list.length; i++) {\n        var a = o.interactions.list[i],\n            s = r;\n        if (a.simulation && a.simulation.allowResume && a.pointerType === e) for (; s;) {\n          if (s === a.element) return a;\n          s = S.parentNode(s);\n        }\n      }\n\n      return null;\n    },\n    mouseOrPen: function mouseOrPen(t) {\n      var e,\n          n = t.pointerId,\n          r = t.pointerType,\n          o = t.eventType,\n          i = t.scope;\n      if (\"mouse\" !== r && \"pen\" !== r) return null;\n\n      for (var a = 0; a < i.interactions.list.length; a++) {\n        var s = i.interactions.list[a];\n\n        if (s.pointerType === r) {\n          if (s.simulation && !Fn(s, n)) continue;\n          if (s.interacting()) return s;\n          e || (e = s);\n        }\n      }\n\n      if (e) return e;\n\n      for (var l = 0; l < i.interactions.list.length; l++) {\n        var u = i.interactions.list[l];\n        if (!(u.pointerType !== r || /down/i.test(o) && u.simulation)) return u;\n      }\n\n      return null;\n    },\n    hasPointer: function hasPointer(t) {\n      for (var e = t.pointerId, n = t.scope, r = 0; r < n.interactions.list.length; r++) {\n        var o = n.interactions.list[r];\n        if (Fn(o, e)) return o;\n      }\n\n      return null;\n    },\n    idle: function idle(t) {\n      for (var e = t.pointerType, n = t.scope, r = 0; r < n.interactions.list.length; r++) {\n        var o = n.interactions.list[r];\n\n        if (1 === o.pointers.length) {\n          var i = o.interactable;\n          if (i && (!i.options.gesture || !i.options.gesture.enabled)) continue;\n        } else if (o.pointers.length >= 2) continue;\n\n        if (!o.interacting() && e === o.pointerType) return o;\n      }\n\n      return null;\n    }\n  };\n\n  function Fn(t, e) {\n    return t.pointers.some(function (t) {\n      return t.id === e;\n    });\n  }\n\n  var Xn = Rn;\n  Cn.default = Xn;\n  var Yn = {};\n\n  function Wn(t) {\n    return (Wn = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  function Ln(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n      var n = [],\n          r = !0,\n          o = !1,\n          i = void 0;\n\n      try {\n        for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);\n      } catch (t) {\n        o = !0, i = t;\n      } finally {\n        try {\n          r || null == s.return || s.return();\n        } finally {\n          if (o) throw i;\n        }\n      }\n\n      return n;\n    }(t, e) || function (t, e) {\n      if (!t) return;\n      if (\"string\" == typeof t) return Bn(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      \"Object\" === n && t.constructor && (n = t.constructor.name);\n      if (\"Map\" === n || \"Set\" === n) return Array.from(t);\n      if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Bn(t, e);\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function Bn(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  function Un(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function Vn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function qn(t, e) {\n    return (qn = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function Nn(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var n,\n          r = Gn(t);\n\n      if (e) {\n        var o = Gn(this).constructor;\n        n = Reflect.construct(r, arguments, o);\n      } else n = r.apply(this, arguments);\n\n      return $n(this, n);\n    };\n  }\n\n  function $n(t, e) {\n    return !e || \"object\" !== Wn(e) && \"function\" != typeof e ? function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }(t) : e;\n  }\n\n  function Gn(t) {\n    return (Gn = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n\n  Object.defineProperty(Yn, \"__esModule\", {\n    value: !0\n  }), Yn.default = void 0;\n  var Hn = [\"pointerDown\", \"pointerMove\", \"pointerUp\", \"updatePointer\", \"removePointer\", \"windowBlur\"];\n\n  function Kn(t, e) {\n    return function (n) {\n      var r = e.interactions.list,\n          o = L.getPointerType(n),\n          i = Ln(L.getEventTargets(n), 2),\n          a = i[0],\n          s = i[1],\n          l = [];\n\n      if (/^touch/.test(n.type)) {\n        e.prevTouchTime = e.now();\n\n        for (var u = 0; u < n.changedTouches.length; u++) {\n          var c = n.changedTouches[u],\n              f = {\n            pointer: c,\n            pointerId: L.getPointerId(c),\n            pointerType: o,\n            eventType: n.type,\n            eventTarget: a,\n            curEventTarget: s,\n            scope: e\n          },\n              d = Zn(f);\n          l.push([f.pointer, f.eventTarget, f.curEventTarget, d]);\n        }\n      } else {\n        var p = !1;\n\n        if (!x.default.supportsPointerEvent && /mouse/.test(n.type)) {\n          for (var v = 0; v < r.length && !p; v++) p = \"mouse\" !== r[v].pointerType && r[v].pointerIsDown;\n\n          p = p || e.now() - e.prevTouchTime < 500 || 0 === n.timeStamp;\n        }\n\n        if (!p) {\n          var h = {\n            pointer: n,\n            pointerId: L.getPointerId(n),\n            pointerType: o,\n            eventType: n.type,\n            curEventTarget: s,\n            eventTarget: a,\n            scope: e\n          },\n              g = Zn(h);\n          l.push([h.pointer, h.eventTarget, h.curEventTarget, g]);\n        }\n      }\n\n      for (var y = 0; y < l.length; y++) {\n        var m = Ln(l[y], 4),\n            b = m[0],\n            w = m[1],\n            _ = m[2];\n        m[3][t](b, n, w, _);\n      }\n    };\n  }\n\n  function Zn(t) {\n    var e = t.pointerType,\n        n = t.scope,\n        r = {\n      interaction: Cn.default.search(t),\n      searchDetails: t\n    };\n    return n.fire(\"interactions:find\", r), r.interaction || n.interactions.new({\n      pointerType: e\n    });\n  }\n\n  function Jn(t, e) {\n    var n = t.doc,\n        r = t.scope,\n        o = t.options,\n        i = r.interactions.docEvents,\n        a = r.events,\n        s = a[e];\n\n    for (var l in r.browser.isIOS && !o.events && (o.events = {\n      passive: !1\n    }), a.delegatedEvents) s(n, l, a.delegateListener), s(n, l, a.delegateUseCapture, !0);\n\n    for (var u = o && o.events, c = 0; c < i.length; c++) {\n      var f = i[c];\n      s(n, f.type, f.listener, u);\n    }\n  }\n\n  var Qn = {\n    id: \"core/interactions\",\n    install: function install(t) {\n      for (var e = {}, n = 0; n < Hn.length; n++) {\n        var r = Hn[n];\n        e[r] = Kn(r, t);\n      }\n\n      var o,\n          i = x.default.pEventTypes;\n\n      function a() {\n        for (var e = 0; e < t.interactions.list.length; e++) {\n          var n = t.interactions.list[e];\n          if (n.pointerIsDown && \"touch\" === n.pointerType && !n._interacting) for (var r = function r() {\n            var e = n.pointers[o];\n            t.documents.some(function (t) {\n              var n = t.doc;\n              return (0, S.nodeContains)(n, e.downTarget);\n            }) || n.removePointer(e.pointer, e.event);\n          }, o = 0; o < n.pointers.length; o++) {\n            r();\n          }\n        }\n      }\n\n      (o = g.default.PointerEvent ? [{\n        type: i.down,\n        listener: a\n      }, {\n        type: i.down,\n        listener: e.pointerDown\n      }, {\n        type: i.move,\n        listener: e.pointerMove\n      }, {\n        type: i.up,\n        listener: e.pointerUp\n      }, {\n        type: i.cancel,\n        listener: e.pointerUp\n      }] : [{\n        type: \"mousedown\",\n        listener: e.pointerDown\n      }, {\n        type: \"mousemove\",\n        listener: e.pointerMove\n      }, {\n        type: \"mouseup\",\n        listener: e.pointerUp\n      }, {\n        type: \"touchstart\",\n        listener: a\n      }, {\n        type: \"touchstart\",\n        listener: e.pointerDown\n      }, {\n        type: \"touchmove\",\n        listener: e.pointerMove\n      }, {\n        type: \"touchend\",\n        listener: e.pointerUp\n      }, {\n        type: \"touchcancel\",\n        listener: e.pointerUp\n      }]).push({\n        type: \"blur\",\n        listener: function listener(e) {\n          for (var n = 0; n < t.interactions.list.length; n++) {\n            t.interactions.list[n].documentBlur(e);\n          }\n        }\n      }), t.prevTouchTime = 0, t.Interaction = function (e) {\n        !function (t, e) {\n          if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n          t.prototype = Object.create(e && e.prototype, {\n            constructor: {\n              value: t,\n              writable: !0,\n              configurable: !0\n            }\n          }), e && qn(t, e);\n        }(a, e);\n        var n,\n            r,\n            o,\n            i = Nn(a);\n\n        function a() {\n          return Un(this, a), i.apply(this, arguments);\n        }\n\n        return n = a, (r = [{\n          key: \"_now\",\n          value: function value() {\n            return t.now();\n          }\n        }, {\n          key: \"pointerMoveTolerance\",\n          get: function get() {\n            return t.interactions.pointerMoveTolerance;\n          },\n          set: function set(e) {\n            t.interactions.pointerMoveTolerance = e;\n          }\n        }]) && Vn(n.prototype, r), o && Vn(n, o), a;\n      }(Ge.default), t.interactions = {\n        list: [],\n        new: function _new(e) {\n          e.scopeFire = function (e, n) {\n            return t.fire(e, n);\n          };\n\n          var n = new t.Interaction(e);\n          return t.interactions.list.push(n), n;\n        },\n        listeners: e,\n        docEvents: o,\n        pointerMoveTolerance: 1\n      }, t.usePlugin(ue.default);\n    },\n    listeners: {\n      \"scope:add-document\": function scopeAddDocument(t) {\n        return Jn(t, \"add\");\n      },\n      \"scope:remove-document\": function scopeRemoveDocument(t) {\n        return Jn(t, \"remove\");\n      },\n      \"interactable:unset\": function interactableUnset(t, e) {\n        for (var n = t.interactable, r = e.interactions.list.length - 1; r >= 0; r--) {\n          var o = e.interactions.list[r];\n          o.interactable === n && (o.stop(), e.fire(\"interactions:destroy\", {\n            interaction: o\n          }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(r, 1));\n        }\n      }\n    },\n    onDocSignal: Jn,\n    doOnInteractions: Kn,\n    methodNames: Hn\n  };\n  Yn.default = Qn;\n  var tr = {};\n\n  function er(t) {\n    return (er = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  function nr(t, e, n) {\n    return (nr = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {\n      var r = function (t, e) {\n        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = ar(t)););\n\n        return t;\n      }(t, e);\n\n      if (r) {\n        var o = Object.getOwnPropertyDescriptor(r, e);\n        return o.get ? o.get.call(n) : o.value;\n      }\n    })(t, e, n || t);\n  }\n\n  function rr(t, e) {\n    return (rr = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function or(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var n,\n          r = ar(t);\n\n      if (e) {\n        var o = ar(this).constructor;\n        n = Reflect.construct(r, arguments, o);\n      } else n = r.apply(this, arguments);\n\n      return ir(this, n);\n    };\n  }\n\n  function ir(t, e) {\n    return !e || \"object\" !== er(e) && \"function\" != typeof e ? function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }(t) : e;\n  }\n\n  function ar(t) {\n    return (ar = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n\n  function sr(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function lr(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function ur(t, e, n) {\n    return e && lr(t.prototype, e), n && lr(t, n), t;\n  }\n\n  Object.defineProperty(tr, \"__esModule\", {\n    value: !0\n  }), tr.initScope = fr, tr.Scope = void 0;\n\n  var cr = function () {\n    function t() {\n      var e = this;\n      sr(this, t), this.id = \"__interact_scope_\".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = x.default, this.defaults = (0, Pe.default)(Ce.defaults), this.Eventable = hn.Eventable, this.actions = {\n        map: {},\n        phases: {\n          start: !0,\n          move: !0,\n          end: !0\n        },\n        methodDict: {},\n        phaselessTypes: {}\n      }, this.interactStatic = (0, zn.createInteractStatic)(this), this.InteractEvent = Re.InteractEvent, this.Interactable = void 0, this.interactables = new Pn.InteractableSet(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = {\n        list: [],\n        map: {}\n      }, this.onWindowUnload = function (t) {\n        return e.removeDocument(t.target);\n      };\n      var n = this;\n\n      this.Interactable = function (t) {\n        !function (t, e) {\n          if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n          t.prototype = Object.create(e && e.prototype, {\n            constructor: {\n              value: t,\n              writable: !0,\n              configurable: !0\n            }\n          }), e && rr(t, e);\n        }(r, t);\n        var e = or(r);\n\n        function r() {\n          return sr(this, r), e.apply(this, arguments);\n        }\n\n        return ur(r, [{\n          key: \"set\",\n          value: function value(t) {\n            return nr(ar(r.prototype), \"set\", this).call(this, t), n.fire(\"interactable:set\", {\n              options: t,\n              interactable: this\n            }), this;\n          }\n        }, {\n          key: \"unset\",\n          value: function value() {\n            nr(ar(r.prototype), \"unset\", this).call(this), n.interactables.list.splice(n.interactables.list.indexOf(this), 1), n.fire(\"interactable:unset\", {\n              interactable: this\n            });\n          }\n        }, {\n          key: \"_defaults\",\n          get: function get() {\n            return n.defaults;\n          }\n        }]), r;\n      }(xn.Interactable);\n    }\n\n    return ur(t, [{\n      key: \"addListeners\",\n      value: function value(t, e) {\n        this.listenerMaps.push({\n          id: e,\n          map: t\n        });\n      }\n    }, {\n      key: \"fire\",\n      value: function value(t, e) {\n        for (var n = 0; n < this.listenerMaps.length; n++) {\n          var r = this.listenerMaps[n].map[t];\n          if (r && !1 === r(e, this, t)) return !1;\n        }\n      }\n    }, {\n      key: \"init\",\n      value: function value(t) {\n        return this.isInitialized ? this : fr(this, t);\n      }\n    }, {\n      key: \"pluginIsInstalled\",\n      value: function value(t) {\n        return this._plugins.map[t.id] || -1 !== this._plugins.list.indexOf(t);\n      }\n    }, {\n      key: \"usePlugin\",\n      value: function value(t, e) {\n        if (!this.isInitialized) return this;\n        if (this.pluginIsInstalled(t)) return this;\n\n        if (t.id && (this._plugins.map[t.id] = t), this._plugins.list.push(t), t.install && t.install(this, e), t.listeners && t.before) {\n          for (var n = 0, r = this.listenerMaps.length, o = t.before.reduce(function (t, e) {\n            return t[e] = !0, t[dr(e)] = !0, t;\n          }, {}); n < r; n++) {\n            var i = this.listenerMaps[n].id;\n            if (o[i] || o[dr(i)]) break;\n          }\n\n          this.listenerMaps.splice(n, 0, {\n            id: t.id,\n            map: t.listeners\n          });\n        } else t.listeners && this.listenerMaps.push({\n          id: t.id,\n          map: t.listeners\n        });\n\n        return this;\n      }\n    }, {\n      key: \"addDocument\",\n      value: function value(t, n) {\n        if (-1 !== this.getDocIndex(t)) return !1;\n        var r = e.default.getWindow(t);\n        n = n ? (0, k.default)({}, n) : {}, this.documents.push({\n          doc: t,\n          options: n\n        }), this.events.documents.push(t), t !== this.document && this.events.add(r, \"unload\", this.onWindowUnload), this.fire(\"scope:add-document\", {\n          doc: t,\n          window: r,\n          scope: this,\n          options: n\n        });\n      }\n    }, {\n      key: \"removeDocument\",\n      value: function value(t) {\n        var n = this.getDocIndex(t),\n            r = e.default.getWindow(t),\n            o = this.documents[n].options;\n        this.events.remove(r, \"unload\", this.onWindowUnload), this.documents.splice(n, 1), this.events.documents.splice(n, 1), this.fire(\"scope:remove-document\", {\n          doc: t,\n          window: r,\n          scope: this,\n          options: o\n        });\n      }\n    }, {\n      key: \"getDocIndex\",\n      value: function value(t) {\n        for (var e = 0; e < this.documents.length; e++) if (this.documents[e].doc === t) return e;\n\n        return -1;\n      }\n    }, {\n      key: \"getDocOptions\",\n      value: function value(t) {\n        var e = this.getDocIndex(t);\n        return -1 === e ? null : this.documents[e].options;\n      }\n    }, {\n      key: \"now\",\n      value: function value() {\n        return (this.window.Date || Date).now();\n      }\n    }]), t;\n  }();\n\n  function fr(t, n) {\n    return t.isInitialized = !0, e.default.init(n), g.default.init(n), x.default.init(n), kt.default.init(n), t.window = n, t.document = n.document, t.usePlugin(Yn.default), t.usePlugin(Tn.default), t;\n  }\n\n  function dr(t) {\n    return t && t.replace(/\\/.*$/, \"\");\n  }\n\n  tr.Scope = cr;\n  var pr = {};\n\n  function vr(t) {\n    return (vr = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  Object.defineProperty(pr, \"__esModule\", {\n    value: !0\n  }), pr.init = pr.default = void 0;\n  var hr = new tr.Scope(),\n      gr = hr.interactStatic;\n  pr.default = gr;\n\n  var yr = function yr(t) {\n    return hr.init(t);\n  };\n\n  pr.init = yr, \"object\" === (\"undefined\" == typeof window ? \"undefined\" : vr(window)) && window && yr(window);\n  var mr = {};\n  Object.defineProperty(mr, \"__esModule\", {\n    value: !0\n  }), mr.default = void 0;\n\n  mr.default = function () {};\n\n  var br = {};\n  Object.defineProperty(br, \"__esModule\", {\n    value: !0\n  }), br.default = void 0;\n\n  br.default = function () {};\n\n  var xr = {};\n\n  function wr(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n      var n = [],\n          r = !0,\n          o = !1,\n          i = void 0;\n\n      try {\n        for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);\n      } catch (t) {\n        o = !0, i = t;\n      } finally {\n        try {\n          r || null == s.return || s.return();\n        } finally {\n          if (o) throw i;\n        }\n      }\n\n      return n;\n    }(t, e) || function (t, e) {\n      if (!t) return;\n      if (\"string\" == typeof t) return _r(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      \"Object\" === n && t.constructor && (n = t.constructor.name);\n      if (\"Map\" === n || \"Set\" === n) return Array.from(t);\n      if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _r(t, e);\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function _r(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  Object.defineProperty(xr, \"__esModule\", {\n    value: !0\n  }), xr.default = void 0;\n\n  xr.default = function (t) {\n    var e = [[\"x\", \"y\"], [\"left\", \"top\"], [\"right\", \"bottom\"], [\"width\", \"height\"]].filter(function (e) {\n      var n = wr(e, 2),\n          r = n[0],\n          o = n[1];\n      return r in t || o in t;\n    }),\n        n = function n(_n2, r) {\n      for (var o = t.range, i = t.limits, a = void 0 === i ? {\n        left: -1 / 0,\n        right: 1 / 0,\n        top: -1 / 0,\n        bottom: 1 / 0\n      } : i, s = t.offset, l = void 0 === s ? {\n        x: 0,\n        y: 0\n      } : s, u = {\n        range: o,\n        grid: t,\n        x: null,\n        y: null\n      }, c = 0; c < e.length; c++) {\n        var f = wr(e[c], 2),\n            d = f[0],\n            p = f[1],\n            v = Math.round((_n2 - l.x) / t[d]),\n            h = Math.round((r - l.y) / t[p]);\n        u[d] = Math.max(a.left, Math.min(a.right, v * t[d] + l.x)), u[p] = Math.max(a.top, Math.min(a.bottom, h * t[p] + l.y));\n      }\n\n      return u;\n    };\n\n    return n.grid = t, n.coordFields = e, n;\n  };\n\n  var Sr = {};\n  Object.defineProperty(Sr, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(Sr, \"edgeTarget\", {\n    enumerable: !0,\n    get: function get() {\n      return mr.default;\n    }\n  }), Object.defineProperty(Sr, \"elements\", {\n    enumerable: !0,\n    get: function get() {\n      return br.default;\n    }\n  }), Object.defineProperty(Sr, \"grid\", {\n    enumerable: !0,\n    get: function get() {\n      return xr.default;\n    }\n  });\n  var Pr = {};\n  Object.defineProperty(Pr, \"__esModule\", {\n    value: !0\n  }), Pr.default = void 0;\n  var Or = {\n    id: \"snappers\",\n    install: function install(t) {\n      var e = t.interactStatic;\n      e.snappers = (0, k.default)(e.snappers || {}, Sr), e.createSnapGrid = e.snappers.grid;\n    }\n  };\n  Pr.default = Or;\n  var Er = {};\n\n  function Tr(t, e) {\n    var n = Object.keys(t);\n\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(t);\n      e && (r = r.filter(function (e) {\n        return Object.getOwnPropertyDescriptor(t, e).enumerable;\n      })), n.push.apply(n, r);\n    }\n\n    return n;\n  }\n\n  function Mr(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? Tr(Object(n), !0).forEach(function (e) {\n        jr(t, e, n[e]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Tr(Object(n)).forEach(function (e) {\n        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e));\n      });\n    }\n\n    return t;\n  }\n\n  function jr(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n\n  Object.defineProperty(Er, \"__esModule\", {\n    value: !0\n  }), Er.aspectRatio = Er.default = void 0;\n  var kr = {\n    start: function start(t) {\n      var e = t.state,\n          n = t.rect,\n          r = t.edges,\n          o = t.pageCoords,\n          i = e.options.ratio,\n          a = e.options,\n          s = a.equalDelta,\n          l = a.modifiers;\n      \"preserve\" === i && (i = n.width / n.height), e.startCoords = (0, k.default)({}, o), e.startRect = (0, k.default)({}, n), e.ratio = i, e.equalDelta = s;\n      var u = e.linkedEdges = {\n        top: r.top || r.left && !r.bottom,\n        left: r.left || r.top && !r.right,\n        bottom: r.bottom || r.right && !r.top,\n        right: r.right || r.bottom && !r.left\n      };\n      if (e.xIsPrimaryAxis = !(!r.left && !r.right), e.equalDelta) e.edgeSign = (u.left ? 1 : -1) * (u.top ? 1 : -1);else {\n        var c = e.xIsPrimaryAxis ? u.top : u.left;\n        e.edgeSign = c ? -1 : 1;\n      }\n\n      if ((0, k.default)(t.edges, u), l && l.length) {\n        var f = new Oe.default(t.interaction);\n        f.copyFrom(t.interaction.modification), f.prepareStates(l), e.subModification = f, f.startAll(Mr({}, t));\n      }\n    },\n    set: function set(t) {\n      var e = t.state,\n          n = t.rect,\n          r = t.coords,\n          o = (0, k.default)({}, r),\n          i = e.equalDelta ? Ir : Dr;\n      if (i(e, e.xIsPrimaryAxis, r, n), !e.subModification) return null;\n      var a = (0, k.default)({}, n);\n      (0, I.addEdges)(e.linkedEdges, a, {\n        x: r.x - o.x,\n        y: r.y - o.y\n      });\n      var s = e.subModification.setAll(Mr(Mr({}, t), {}, {\n        rect: a,\n        edges: e.linkedEdges,\n        pageCoords: r,\n        prevCoords: r,\n        prevRect: a\n      })),\n          l = s.delta;\n      s.changed && (i(e, Math.abs(l.x) > Math.abs(l.y), s.coords, s.rect), (0, k.default)(r, s.coords));\n      return s.eventProps;\n    },\n    defaults: {\n      ratio: \"preserve\",\n      equalDelta: !1,\n      modifiers: [],\n      enabled: !1\n    }\n  };\n\n  function Ir(t, e, n) {\n    var r = t.startCoords,\n        o = t.edgeSign;\n    e ? n.y = r.y + (n.x - r.x) * o : n.x = r.x + (n.y - r.y) * o;\n  }\n\n  function Dr(t, e, n, r) {\n    var o = t.startRect,\n        i = t.startCoords,\n        a = t.ratio,\n        s = t.edgeSign;\n\n    if (e) {\n      var l = r.width / a;\n      n.y = i.y + (l - o.height) * s;\n    } else {\n      var u = r.height * a;\n      n.x = i.x + (u - o.width) * s;\n    }\n  }\n\n  Er.aspectRatio = kr;\n  var Ar = (0, De.makeModifier)(kr, \"aspectRatio\");\n  Er.default = Ar;\n  var zr = {};\n  Object.defineProperty(zr, \"__esModule\", {\n    value: !0\n  }), zr.default = void 0;\n\n  var Cr = function Cr() {};\n\n  Cr._defaults = {};\n  var Rr = Cr;\n  zr.default = Rr;\n  var Fr = {};\n  Object.defineProperty(Fr, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(Fr, \"default\", {\n    enumerable: !0,\n    get: function get() {\n      return zr.default;\n    }\n  });\n  var Xr = {};\n\n  function Yr(t, e, n) {\n    return a.default.func(t) ? I.resolveRectLike(t, e.interactable, e.element, [n.x, n.y, e]) : I.resolveRectLike(t, e.interactable, e.element);\n  }\n\n  Object.defineProperty(Xr, \"__esModule\", {\n    value: !0\n  }), Xr.getRestrictionRect = Yr, Xr.restrict = Xr.default = void 0;\n  var Wr = {\n    start: function start(t) {\n      var e = t.rect,\n          n = t.startOffset,\n          r = t.state,\n          o = t.interaction,\n          i = t.pageCoords,\n          a = r.options,\n          s = a.elementRect,\n          l = (0, k.default)({\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      }, a.offset || {});\n\n      if (e && s) {\n        var u = Yr(a.restriction, o, i);\n\n        if (u) {\n          var c = u.right - u.left - e.width,\n              f = u.bottom - u.top - e.height;\n          c < 0 && (l.left += c, l.right += c), f < 0 && (l.top += f, l.bottom += f);\n        }\n\n        l.left += n.left - e.width * s.left, l.top += n.top - e.height * s.top, l.right += n.right - e.width * (1 - s.right), l.bottom += n.bottom - e.height * (1 - s.bottom);\n      }\n\n      r.offset = l;\n    },\n    set: function set(t) {\n      var e = t.coords,\n          n = t.interaction,\n          r = t.state,\n          o = r.options,\n          i = r.offset,\n          a = Yr(o.restriction, n, e);\n\n      if (a) {\n        var s = I.xywhToTlbr(a);\n        e.x = Math.max(Math.min(s.right - i.right, e.x), s.left + i.left), e.y = Math.max(Math.min(s.bottom - i.bottom, e.y), s.top + i.top);\n      }\n    },\n    defaults: {\n      restriction: null,\n      elementRect: null,\n      offset: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  Xr.restrict = Wr;\n  var Lr = (0, De.makeModifier)(Wr, \"restrict\");\n  Xr.default = Lr;\n  var Br = {};\n  Object.defineProperty(Br, \"__esModule\", {\n    value: !0\n  }), Br.restrictEdges = Br.default = void 0;\n  var Ur = {\n    top: 1 / 0,\n    left: 1 / 0,\n    bottom: -1 / 0,\n    right: -1 / 0\n  },\n      Vr = {\n    top: -1 / 0,\n    left: -1 / 0,\n    bottom: 1 / 0,\n    right: 1 / 0\n  };\n\n  function qr(t, e) {\n    for (var n = [\"top\", \"left\", \"bottom\", \"right\"], r = 0; r < n.length; r++) {\n      var o = n[r];\n      o in t || (t[o] = e[o]);\n    }\n\n    return t;\n  }\n\n  var Nr = {\n    noInner: Ur,\n    noOuter: Vr,\n    start: function start(t) {\n      var e,\n          n = t.interaction,\n          r = t.startOffset,\n          o = t.state,\n          i = o.options;\n\n      if (i) {\n        var a = (0, Xr.getRestrictionRect)(i.offset, n, n.coords.start.page);\n        e = I.rectToXY(a);\n      }\n\n      e = e || {\n        x: 0,\n        y: 0\n      }, o.offset = {\n        top: e.y + r.top,\n        left: e.x + r.left,\n        bottom: e.y - r.bottom,\n        right: e.x - r.right\n      };\n    },\n    set: function set(t) {\n      var e = t.coords,\n          n = t.edges,\n          r = t.interaction,\n          o = t.state,\n          i = o.offset,\n          a = o.options;\n\n      if (n) {\n        var s = (0, k.default)({}, e),\n            l = (0, Xr.getRestrictionRect)(a.inner, r, s) || {},\n            u = (0, Xr.getRestrictionRect)(a.outer, r, s) || {};\n        qr(l, Ur), qr(u, Vr), n.top ? e.y = Math.min(Math.max(u.top + i.top, s.y), l.top + i.top) : n.bottom && (e.y = Math.max(Math.min(u.bottom + i.bottom, s.y), l.bottom + i.bottom)), n.left ? e.x = Math.min(Math.max(u.left + i.left, s.x), l.left + i.left) : n.right && (e.x = Math.max(Math.min(u.right + i.right, s.x), l.right + i.right));\n      }\n    },\n    defaults: {\n      inner: null,\n      outer: null,\n      offset: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  Br.restrictEdges = Nr;\n  var $r = (0, De.makeModifier)(Nr, \"restrictEdges\");\n  Br.default = $r;\n  var Gr = {};\n  Object.defineProperty(Gr, \"__esModule\", {\n    value: !0\n  }), Gr.restrictRect = Gr.default = void 0;\n  var Hr = (0, k.default)({\n    get elementRect() {\n      return {\n        top: 0,\n        left: 0,\n        bottom: 1,\n        right: 1\n      };\n    },\n\n    set elementRect(t) {}\n\n  }, Xr.restrict.defaults),\n      Kr = {\n    start: Xr.restrict.start,\n    set: Xr.restrict.set,\n    defaults: Hr\n  };\n  Gr.restrictRect = Kr;\n  var Zr = (0, De.makeModifier)(Kr, \"restrictRect\");\n  Gr.default = Zr;\n  var Jr = {};\n  Object.defineProperty(Jr, \"__esModule\", {\n    value: !0\n  }), Jr.restrictSize = Jr.default = void 0;\n  var Qr = {\n    width: -1 / 0,\n    height: -1 / 0\n  },\n      to = {\n    width: 1 / 0,\n    height: 1 / 0\n  };\n  var eo = {\n    start: function start(t) {\n      return Br.restrictEdges.start(t);\n    },\n    set: function set(t) {\n      var e = t.interaction,\n          n = t.state,\n          r = t.rect,\n          o = t.edges,\n          i = n.options;\n\n      if (o) {\n        var a = I.tlbrToXywh((0, Xr.getRestrictionRect)(i.min, e, t.coords)) || Qr,\n            s = I.tlbrToXywh((0, Xr.getRestrictionRect)(i.max, e, t.coords)) || to;\n        n.options = {\n          endOnly: i.endOnly,\n          inner: (0, k.default)({}, Br.restrictEdges.noInner),\n          outer: (0, k.default)({}, Br.restrictEdges.noOuter)\n        }, o.top ? (n.options.inner.top = r.bottom - a.height, n.options.outer.top = r.bottom - s.height) : o.bottom && (n.options.inner.bottom = r.top + a.height, n.options.outer.bottom = r.top + s.height), o.left ? (n.options.inner.left = r.right - a.width, n.options.outer.left = r.right - s.width) : o.right && (n.options.inner.right = r.left + a.width, n.options.outer.right = r.left + s.width), Br.restrictEdges.set(t), n.options = i;\n      }\n    },\n    defaults: {\n      min: null,\n      max: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  Jr.restrictSize = eo;\n  var no = (0, De.makeModifier)(eo, \"restrictSize\");\n  Jr.default = no;\n  var ro = {};\n  Object.defineProperty(ro, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(ro, \"default\", {\n    enumerable: !0,\n    get: function get() {\n      return zr.default;\n    }\n  });\n  var oo = {};\n  Object.defineProperty(oo, \"__esModule\", {\n    value: !0\n  }), oo.snap = oo.default = void 0;\n  var io = {\n    start: function start(t) {\n      var e,\n          n = t.interaction,\n          r = t.interactable,\n          o = t.element,\n          i = t.rect,\n          a = t.state,\n          s = t.startOffset,\n          l = a.options,\n          u = l.offsetWithOrigin ? function (t) {\n        var e = t.interaction.element;\n        return (0, I.rectToXY)((0, I.resolveRectLike)(t.state.options.origin, null, null, [e])) || (0, z.default)(t.interactable, e, t.interaction.prepared.name);\n      }(t) : {\n        x: 0,\n        y: 0\n      };\n      if (\"startCoords\" === l.offset) e = {\n        x: n.coords.start.page.x,\n        y: n.coords.start.page.y\n      };else {\n        var c = (0, I.resolveRectLike)(l.offset, r, o, [n]);\n        (e = (0, I.rectToXY)(c) || {\n          x: 0,\n          y: 0\n        }).x += u.x, e.y += u.y;\n      }\n      var f = l.relativePoints;\n      a.offsets = i && f && f.length ? f.map(function (t, n) {\n        return {\n          index: n,\n          relativePoint: t,\n          x: s.left - i.width * t.x + e.x,\n          y: s.top - i.height * t.y + e.y\n        };\n      }) : [(0, k.default)({\n        index: 0,\n        relativePoint: null\n      }, e)];\n    },\n    set: function set(t) {\n      var e = t.interaction,\n          n = t.coords,\n          r = t.state,\n          o = r.options,\n          i = r.offsets,\n          s = (0, z.default)(e.interactable, e.element, e.prepared.name),\n          l = (0, k.default)({}, n),\n          u = [];\n      o.offsetWithOrigin || (l.x -= s.x, l.y -= s.y);\n\n      for (var c = 0; c < i.length; c++) for (var f = i[c], d = l.x - f.x, p = l.y - f.y, v = 0, h = o.targets.length; v < h; v++) {\n        var g = o.targets[v],\n            y = void 0;\n        (y = a.default.func(g) ? g(d, p, e._proxy, f, v) : g) && u.push({\n          x: (a.default.number(y.x) ? y.x : d) + f.x,\n          y: (a.default.number(y.y) ? y.y : p) + f.y,\n          range: a.default.number(y.range) ? y.range : o.range,\n          source: g,\n          index: v,\n          offset: f\n        });\n      }\n\n      for (var m = {\n        target: null,\n        inRange: !1,\n        distance: 0,\n        range: 0,\n        delta: {\n          x: 0,\n          y: 0\n        }\n      }, b = 0; b < u.length; b++) {\n        var x = u[b],\n            w = x.range,\n            _ = x.x - l.x,\n            S = x.y - l.y,\n            P = (0, F.default)(_, S),\n            O = P <= w;\n\n        w === 1 / 0 && m.inRange && m.range !== 1 / 0 && (O = !1), m.target && !(O ? m.inRange && w !== 1 / 0 ? P / w < m.distance / m.range : w === 1 / 0 && m.range !== 1 / 0 || P < m.distance : !m.inRange && P < m.distance) || (m.target = x, m.distance = P, m.range = w, m.inRange = O, m.delta.x = _, m.delta.y = S);\n      }\n\n      return m.inRange && (n.x = m.target.x, n.y = m.target.y), r.closest = m, m;\n    },\n    defaults: {\n      range: 1 / 0,\n      targets: null,\n      offset: null,\n      offsetWithOrigin: !0,\n      origin: null,\n      relativePoints: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  oo.snap = io;\n  var ao = (0, De.makeModifier)(io, \"snap\");\n  oo.default = ao;\n  var so = {};\n\n  function lo(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(t))) return;\n      var n = [],\n          r = !0,\n          o = !1,\n          i = void 0;\n\n      try {\n        for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);\n      } catch (t) {\n        o = !0, i = t;\n      } finally {\n        try {\n          r || null == s.return || s.return();\n        } finally {\n          if (o) throw i;\n        }\n      }\n\n      return n;\n    }(t, e) || function (t, e) {\n      if (!t) return;\n      if (\"string\" == typeof t) return uo(t, e);\n      var n = Object.prototype.toString.call(t).slice(8, -1);\n      \"Object\" === n && t.constructor && (n = t.constructor.name);\n      if (\"Map\" === n || \"Set\" === n) return Array.from(t);\n      if (\"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return uo(t, e);\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n\n  function uo(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n\n    return r;\n  }\n\n  Object.defineProperty(so, \"__esModule\", {\n    value: !0\n  }), so.snapSize = so.default = void 0;\n  var co = {\n    start: function start(t) {\n      var e = t.state,\n          n = t.edges,\n          r = e.options;\n      if (!n) return null;\n      t.state = {\n        options: {\n          targets: null,\n          relativePoints: [{\n            x: n.left ? 0 : 1,\n            y: n.top ? 0 : 1\n          }],\n          offset: r.offset || \"self\",\n          origin: {\n            x: 0,\n            y: 0\n          },\n          range: r.range\n        }\n      }, e.targetFields = e.targetFields || [[\"width\", \"height\"], [\"x\", \"y\"]], oo.snap.start(t), e.offsets = t.state.offsets, t.state = e;\n    },\n    set: function set(t) {\n      var e = t.interaction,\n          n = t.state,\n          r = t.coords,\n          o = n.options,\n          i = n.offsets,\n          s = {\n        x: r.x - i[0].x,\n        y: r.y - i[0].y\n      };\n      n.options = (0, k.default)({}, o), n.options.targets = [];\n\n      for (var l = 0; l < (o.targets || []).length; l++) {\n        var u = (o.targets || [])[l],\n            c = void 0;\n\n        if (c = a.default.func(u) ? u(s.x, s.y, e) : u) {\n          for (var f = 0; f < n.targetFields.length; f++) {\n            var d = lo(n.targetFields[f], 2),\n                p = d[0],\n                v = d[1];\n\n            if (p in c || v in c) {\n              c.x = c[p], c.y = c[v];\n              break;\n            }\n          }\n\n          n.options.targets.push(c);\n        }\n      }\n\n      var h = oo.snap.set(t);\n      return n.options = o, h;\n    },\n    defaults: {\n      range: 1 / 0,\n      targets: null,\n      offset: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  so.snapSize = co;\n  var fo = (0, De.makeModifier)(co, \"snapSize\");\n  so.default = fo;\n  var po = {};\n  Object.defineProperty(po, \"__esModule\", {\n    value: !0\n  }), po.snapEdges = po.default = void 0;\n  var vo = {\n    start: function start(t) {\n      var e = t.edges;\n      return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? \"left\" : \"right\", e.top ? \"top\" : \"bottom\"]], so.snapSize.start(t)) : null;\n    },\n    set: so.snapSize.set,\n    defaults: (0, k.default)((0, Pe.default)(so.snapSize.defaults), {\n      targets: null,\n      range: null,\n      offset: {\n        x: 0,\n        y: 0\n      }\n    })\n  };\n  po.snapEdges = vo;\n  var ho = (0, De.makeModifier)(vo, \"snapEdges\");\n  po.default = ho;\n  var go = {};\n  Object.defineProperty(go, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(go, \"default\", {\n    enumerable: !0,\n    get: function get() {\n      return zr.default;\n    }\n  });\n  var yo = {};\n  Object.defineProperty(yo, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(yo, \"default\", {\n    enumerable: !0,\n    get: function get() {\n      return zr.default;\n    }\n  });\n  var mo = {};\n  Object.defineProperty(mo, \"__esModule\", {\n    value: !0\n  }), mo.default = void 0;\n  var bo = {\n    aspectRatio: Er.default,\n    restrictEdges: Br.default,\n    restrict: Xr.default,\n    restrictRect: Gr.default,\n    restrictSize: Jr.default,\n    snapEdges: po.default,\n    snap: oo.default,\n    snapSize: so.default,\n    spring: go.default,\n    avoid: Fr.default,\n    transform: yo.default,\n    rubberband: ro.default\n  };\n  mo.default = bo;\n  var xo = {};\n  Object.defineProperty(xo, \"__esModule\", {\n    value: !0\n  }), xo.default = void 0;\n  var wo = {\n    id: \"modifiers\",\n    install: function install(t) {\n      var e = t.interactStatic;\n\n      for (var n in t.usePlugin(De.default), t.usePlugin(Pr.default), e.modifiers = mo.default, mo.default) {\n        var r = mo.default[n],\n            o = r._defaults,\n            i = r._methods;\n        o._methods = i, t.defaults.perAction[n] = o;\n      }\n    }\n  };\n  xo.default = wo;\n  var _o = {};\n  Object.defineProperty(_o, \"__esModule\", {\n    value: !0\n  }), _o.default = void 0;\n  _o.default = {};\n  var So = {};\n\n  function Po(t) {\n    return (Po = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  function Oo(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n\n  function Eo(t, e) {\n    return (Eo = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(t, e);\n  }\n\n  function To(t) {\n    var e = function () {\n      if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n      if (Reflect.construct.sham) return !1;\n      if (\"function\" == typeof Proxy) return !0;\n\n      try {\n        return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n      } catch (t) {\n        return !1;\n      }\n    }();\n\n    return function () {\n      var n,\n          r = ko(t);\n\n      if (e) {\n        var o = ko(this).constructor;\n        n = Reflect.construct(r, arguments, o);\n      } else n = r.apply(this, arguments);\n\n      return Mo(this, n);\n    };\n  }\n\n  function Mo(t, e) {\n    return !e || \"object\" !== Po(e) && \"function\" != typeof e ? jo(t) : e;\n  }\n\n  function jo(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n\n  function ko(t) {\n    return (ko = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    })(t);\n  }\n\n  Object.defineProperty(So, \"__esModule\", {\n    value: !0\n  }), So.PointerEvent = So.default = void 0;\n\n  var Io = function (t) {\n    !function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), e && Eo(t, e);\n    }(i, t);\n    var e,\n        n,\n        r,\n        o = To(i);\n\n    function i(t, e, n, r, a, s) {\n      var l;\n\n      if (function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, i), (l = o.call(this, a)).type = void 0, l.originalEvent = void 0, l.pointerId = void 0, l.pointerType = void 0, l.double = void 0, l.pageX = void 0, l.pageY = void 0, l.clientX = void 0, l.clientY = void 0, l.dt = void 0, l.eventable = void 0, L.pointerExtend(jo(l), n), n !== e && L.pointerExtend(jo(l), e), l.timeStamp = s, l.originalEvent = n, l.type = t, l.pointerId = L.getPointerId(e), l.pointerType = L.getPointerType(e), l.target = r, l.currentTarget = null, \"tap\" === t) {\n        var u = a.getPointerIndex(e);\n        l.dt = l.timeStamp - a.pointers[u].downTime;\n        var c = l.timeStamp - a.tapTime;\n        l.double = !!(a.prevTap && \"doubletap\" !== a.prevTap.type && a.prevTap.target === l.target && c < 500);\n      } else \"doubletap\" === t && (l.dt = e.timeStamp - a.tapTime);\n\n      return l;\n    }\n\n    return e = i, (n = [{\n      key: \"_subtractOrigin\",\n      value: function value(t) {\n        var e = t.x,\n            n = t.y;\n        return this.pageX -= e, this.pageY -= n, this.clientX -= e, this.clientY -= n, this;\n      }\n    }, {\n      key: \"_addOrigin\",\n      value: function value(t) {\n        var e = t.x,\n            n = t.y;\n        return this.pageX += e, this.pageY += n, this.clientX += e, this.clientY += n, this;\n      }\n    }, {\n      key: \"preventDefault\",\n      value: function value() {\n        this.originalEvent.preventDefault();\n      }\n    }]) && Oo(e.prototype, n), r && Oo(e, r), i;\n  }(G.default);\n\n  So.PointerEvent = So.default = Io;\n  var Do = {};\n  Object.defineProperty(Do, \"__esModule\", {\n    value: !0\n  }), Do.default = void 0;\n  var Ao = {\n    id: \"pointer-events/base\",\n    before: [\"inertia\", \"modifiers\", \"auto-start\", \"actions\"],\n    install: function install(t) {\n      t.pointerEvents = Ao, t.defaults.actions.pointerEvents = Ao.defaults, (0, k.default)(t.actions.phaselessTypes, Ao.types);\n    },\n    listeners: {\n      \"interactions:new\": function interactionsNew(t) {\n        var e = t.interaction;\n        e.prevTap = null, e.tapTime = 0;\n      },\n      \"interactions:update-pointer\": function interactionsUpdatePointer(t) {\n        var e = t.down,\n            n = t.pointerInfo;\n        if (!e && n.hold) return;\n        n.hold = {\n          duration: 1 / 0,\n          timeout: null\n        };\n      },\n      \"interactions:move\": function interactionsMove(t, e) {\n        var n = t.interaction,\n            r = t.pointer,\n            o = t.event,\n            i = t.eventTarget,\n            a = t.duplicate,\n            s = n.getPointerIndex(r);\n        a || n.pointerIsDown && !n.pointerWasMoved || (n.pointerIsDown && clearTimeout(n.pointers[s].hold.timeout), zo({\n          interaction: n,\n          pointer: r,\n          event: o,\n          eventTarget: i,\n          type: \"move\"\n        }, e));\n      },\n      \"interactions:down\": function interactionsDown(t, e) {\n        !function (t, e) {\n          for (var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.pointerIndex, s = n.pointers[a].hold, l = S.getPath(i), u = {\n            interaction: n,\n            pointer: r,\n            event: o,\n            eventTarget: i,\n            type: \"hold\",\n            targets: [],\n            path: l,\n            node: null\n          }, c = 0; c < l.length; c++) {\n            var f = l[c];\n            u.node = f, e.fire(\"pointerEvents:collect-targets\", u);\n          }\n\n          if (!u.targets.length) return;\n\n          for (var d = 1 / 0, p = 0; p < u.targets.length; p++) {\n            var v = u.targets[p].eventable.options.holdDuration;\n            v < d && (d = v);\n          }\n\n          s.duration = d, s.timeout = setTimeout(function () {\n            zo({\n              interaction: n,\n              eventTarget: i,\n              pointer: r,\n              event: o,\n              type: \"hold\"\n            }, e);\n          }, d);\n        }(t, e), zo(t, e);\n      },\n      \"interactions:up\": function interactionsUp(t, e) {\n        Ro(t), zo(t, e), function (t, e) {\n          var n = t.interaction,\n              r = t.pointer,\n              o = t.event,\n              i = t.eventTarget;\n          n.pointerWasMoved || zo({\n            interaction: n,\n            eventTarget: i,\n            pointer: r,\n            event: o,\n            type: \"tap\"\n          }, e);\n        }(t, e);\n      },\n      \"interactions:cancel\": function interactionsCancel(t, e) {\n        Ro(t), zo(t, e);\n      }\n    },\n    PointerEvent: So.PointerEvent,\n    fire: zo,\n    collectEventTargets: Co,\n    defaults: {\n      holdDuration: 600,\n      ignoreFrom: null,\n      allowFrom: null,\n      origin: {\n        x: 0,\n        y: 0\n      }\n    },\n    types: {\n      down: !0,\n      move: !0,\n      up: !0,\n      cancel: !0,\n      tap: !0,\n      doubletap: !0,\n      hold: !0\n    }\n  };\n\n  function zo(t, e) {\n    var n = t.interaction,\n        r = t.pointer,\n        o = t.event,\n        i = t.eventTarget,\n        a = t.type,\n        s = t.targets,\n        l = void 0 === s ? Co(t, e) : s,\n        u = new So.PointerEvent(a, r, o, i, n, e.now());\n    e.fire(\"pointerEvents:new\", {\n      pointerEvent: u\n    });\n\n    for (var c = {\n      interaction: n,\n      pointer: r,\n      event: o,\n      eventTarget: i,\n      targets: l,\n      type: a,\n      pointerEvent: u\n    }, f = 0; f < l.length; f++) {\n      var d = l[f];\n\n      for (var p in d.props || {}) u[p] = d.props[p];\n\n      var v = (0, z.default)(d.eventable, d.node);\n      if (u._subtractOrigin(v), u.eventable = d.eventable, u.currentTarget = d.node, d.eventable.fire(u), u._addOrigin(v), u.immediatePropagationStopped || u.propagationStopped && f + 1 < l.length && l[f + 1].node !== u.currentTarget) break;\n    }\n\n    if (e.fire(\"pointerEvents:fired\", c), \"tap\" === a) {\n      var h = u.double ? zo({\n        interaction: n,\n        pointer: r,\n        event: o,\n        eventTarget: i,\n        type: \"doubletap\"\n      }, e) : u;\n      n.prevTap = h, n.tapTime = h.timeStamp;\n    }\n\n    return u;\n  }\n\n  function Co(t, e) {\n    var n = t.interaction,\n        r = t.pointer,\n        o = t.event,\n        i = t.eventTarget,\n        a = t.type,\n        s = n.getPointerIndex(r),\n        l = n.pointers[s];\n    if (\"tap\" === a && (n.pointerWasMoved || !l || l.downTarget !== i)) return [];\n\n    for (var u = S.getPath(i), c = {\n      interaction: n,\n      pointer: r,\n      event: o,\n      eventTarget: i,\n      type: a,\n      path: u,\n      targets: [],\n      node: null\n    }, f = 0; f < u.length; f++) {\n      var d = u[f];\n      c.node = d, e.fire(\"pointerEvents:collect-targets\", c);\n    }\n\n    return \"hold\" === a && (c.targets = c.targets.filter(function (t) {\n      return t.eventable.options.holdDuration === n.pointers[s].hold.duration;\n    })), c.targets;\n  }\n\n  function Ro(t) {\n    var e = t.interaction,\n        n = t.pointerIndex;\n    e.pointers[n].hold && clearTimeout(e.pointers[n].hold.timeout);\n  }\n\n  var Fo = Ao;\n  Do.default = Fo;\n  var Xo = {};\n\n  function Yo(t) {\n    var e = t.interaction;\n    e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);\n  }\n\n  Object.defineProperty(Xo, \"__esModule\", {\n    value: !0\n  }), Xo.default = void 0;\n  var Wo = {\n    id: \"pointer-events/holdRepeat\",\n    install: function install(t) {\n      t.usePlugin(Do.default);\n      var e = t.pointerEvents;\n      e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;\n    },\n    listeners: [\"move\", \"up\", \"cancel\", \"endall\"].reduce(function (t, e) {\n      return t[\"pointerEvents:\".concat(e)] = Yo, t;\n    }, {\n      \"pointerEvents:new\": function pointerEventsNew(t) {\n        var e = t.pointerEvent;\n        \"hold\" === e.type && (e.count = (e.count || 0) + 1);\n      },\n      \"pointerEvents:fired\": function pointerEventsFired(t, e) {\n        var n = t.interaction,\n            r = t.pointerEvent,\n            o = t.eventTarget,\n            i = t.targets;\n\n        if (\"hold\" === r.type && i.length) {\n          var a = i[0].eventable.options.holdRepeatInterval;\n          a <= 0 || (n.holdIntervalHandle = setTimeout(function () {\n            e.pointerEvents.fire({\n              interaction: n,\n              eventTarget: o,\n              type: \"hold\",\n              pointer: r,\n              event: r\n            }, e);\n          }, a));\n        }\n      }\n    })\n  };\n  Xo.default = Wo;\n  var Lo = {};\n\n  function Bo(t) {\n    return (0, k.default)(this.events.options, t), this;\n  }\n\n  Object.defineProperty(Lo, \"__esModule\", {\n    value: !0\n  }), Lo.default = void 0;\n  var Uo = {\n    id: \"pointer-events/interactableTargets\",\n    install: function install(t) {\n      var e = t.Interactable;\n      e.prototype.pointerEvents = Bo;\n      var n = e.prototype._backCompatOption;\n\n      e.prototype._backCompatOption = function (t, e) {\n        var r = n.call(this, t, e);\n        return r === this && (this.events.options[t] = e), r;\n      };\n    },\n    listeners: {\n      \"pointerEvents:collect-targets\": function pointerEventsCollectTargets(t, e) {\n        var n = t.targets,\n            r = t.node,\n            o = t.type,\n            i = t.eventTarget;\n        e.interactables.forEachMatch(r, function (t) {\n          var e = t.events,\n              a = e.options;\n          e.types[o] && e.types[o].length && t.testIgnoreAllow(a, r, i) && n.push({\n            node: r,\n            eventable: e,\n            props: {\n              interactable: t\n            }\n          });\n        });\n      },\n      \"interactable:new\": function interactableNew(t) {\n        var e = t.interactable;\n\n        e.events.getRect = function (t) {\n          return e.getRect(t);\n        };\n      },\n      \"interactable:set\": function interactableSet(t, e) {\n        var n = t.interactable,\n            r = t.options;\n        (0, k.default)(n.events.options, e.pointerEvents.defaults), (0, k.default)(n.events.options, r.pointerEvents || {});\n      }\n    }\n  };\n  Lo.default = Uo;\n  var Vo = {};\n  Object.defineProperty(Vo, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(Vo, \"holdRepeat\", {\n    enumerable: !0,\n    get: function get() {\n      return Xo.default;\n    }\n  }), Object.defineProperty(Vo, \"interactableTargets\", {\n    enumerable: !0,\n    get: function get() {\n      return Lo.default;\n    }\n  }), Vo.pointerEvents = Vo.default = void 0, Vo.pointerEvents = Do;\n  var qo = {\n    id: \"pointer-events\",\n    install: function install(t) {\n      t.usePlugin(Do), t.usePlugin(Xo.default), t.usePlugin(Lo.default);\n    }\n  };\n  Vo.default = qo;\n  var No = {};\n  Object.defineProperty(No, \"__esModule\", {\n    value: !0\n  }), No.default = void 0;\n  No.default = {};\n  var $o = {};\n\n  function Go(t) {\n    var e = t.Interactable;\n    t.actions.phases.reflow = !0, e.prototype.reflow = function (e) {\n      return function (t, e, n) {\n        for (var r = a.default.string(t.target) ? J.from(t._context.querySelectorAll(t.target)) : [t.target], o = n.window.Promise, i = o ? [] : null, s = function s() {\n          var a = r[l],\n              s = t.getRect(a);\n          if (!s) return \"break\";\n          var u = J.find(n.interactions.list, function (n) {\n            return n.interacting() && n.interactable === t && n.element === a && n.prepared.name === e.name;\n          }),\n              c = void 0;\n          if (u) u.move(), i && (c = u._reflowPromise || new o(function (t) {\n            u._reflowResolve = t;\n          }));else {\n            var f = (0, I.tlbrToXywh)(s),\n                d = {\n              page: {\n                x: f.x,\n                y: f.y\n              },\n              client: {\n                x: f.x,\n                y: f.y\n              },\n              timeStamp: n.now()\n            },\n                p = L.coordsToEvent(d);\n\n            c = function (t, e, n, r, o) {\n              var i = t.interactions.new({\n                pointerType: \"reflow\"\n              }),\n                  a = {\n                interaction: i,\n                event: o,\n                pointer: o,\n                eventTarget: n,\n                phase: \"reflow\"\n              };\n              i.interactable = e, i.element = n, i.prepared = (0, k.default)({}, r), i.prevEvent = o, i.updatePointer(o, o, n, !0), i._doPhase(a);\n              var s = t.window.Promise,\n                  l = s ? new s(function (t) {\n                i._reflowResolve = t;\n              }) : null;\n              i._reflowPromise = l, i.start(r, e, n), i._interacting ? (i.move(a), i.end(o)) : i.stop();\n              return i.removePointer(o, o), i.pointerIsDown = !1, l;\n            }(n, t, a, e, p);\n          }\n          i && i.push(c);\n        }, l = 0; l < r.length; l++) {\n          if (\"break\" === s()) break;\n        }\n\n        return i && o.all(i).then(function () {\n          return t;\n        });\n      }(this, e, t);\n    };\n  }\n\n  Object.defineProperty($o, \"__esModule\", {\n    value: !0\n  }), $o.install = Go, $o.default = void 0;\n  var Ho = {\n    id: \"reflow\",\n    install: Go,\n    listeners: {\n      \"interactions:stop\": function interactionsStop(t, e) {\n        var n = t.interaction;\n        \"reflow\" === n.pointerType && (n._reflowResolve && n._reflowResolve(), J.remove(e.interactions.list, n));\n      }\n    }\n  };\n  $o.default = Ho;\n  var Ko = {};\n  Object.defineProperty(Ko, \"__esModule\", {\n    value: !0\n  }), Ko.default = void 0;\n  Ko.default = {};\n  var Zo = {};\n  Object.defineProperty(Zo, \"__esModule\", {\n    value: !0\n  }), Zo.exchange = void 0;\n  Zo.exchange = {};\n  var Jo = {};\n  Object.defineProperty(Jo, \"__esModule\", {\n    value: !0\n  }), Jo.default = void 0;\n  Jo.default = {};\n  var Qo = {\n    exports: {}\n  };\n\n  function ti(t) {\n    return (ti = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  Object.defineProperty(Qo.exports, \"__esModule\", {\n    value: !0\n  }), Qo.exports.default = void 0, pr.default.use(_o.default), pr.default.use(ue.default), pr.default.use(tn.default), pr.default.use(le.default), pr.default.use(jt.default), pr.default.use(Vo.default), pr.default.use(ln.default), pr.default.use(xo.default), pr.default.use(ae.default), pr.default.use(Tt.default), pr.default.use(Ct.default), pr.default.use($o.default), pr.default.use(Se.default), pr.default.use(Jo.default), pr.default.use(No.default), pr.default.__utils = {\n    exchange: Zo.exchange,\n    displace: Ko,\n    pointer: L\n  }, pr.default.use(he.default);\n  var ei = pr.default;\n  if (Qo.exports.default = ei, \"object\" === ti(Qo) && Qo) try {\n    Qo.exports = pr.default;\n  } catch (t) {}\n  pr.default.default = pr.default, Qo = Qo.exports;\n  var ni = {\n    exports: {}\n  };\n\n  function ri(t) {\n    return (ri = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    })(t);\n  }\n\n  Object.defineProperty(ni.exports, \"__esModule\", {\n    value: !0\n  }), ni.exports.default = void 0;\n  var oi = Qo.default;\n  if (ni.exports.default = oi, \"object\" === ri(ni) && ni) try {\n    ni.exports = Qo.default;\n  } catch (t) {}\n  return Qo.default.default = Qo.default, ni = ni.exports;\n});","map":null,"metadata":{},"sourceType":"script"}